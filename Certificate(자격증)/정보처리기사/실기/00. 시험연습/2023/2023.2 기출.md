55/100
### 1. 프로그래밍 언어 - 반복문 (X)

### 2. 프로그래밍 언어 - 단순연산 (X)
- 거지같은 문제

### 3. 프로그래밍 언어 - Pointer (X)
- 주소값 확인

### 4. DB - Query문 (X)
INSERT INTO 테이블명([속성명1, 속성명2, ...]) VALUES (데이터1, 데이터2, ..);

### 5. 프로그래밍 언어 - 출력값 (O)

### 6. 용어 - 화이트박스 테스트 (O)
- 원시코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법
- 모듈 안의 작동을 직접 관찰
- 모든 문장을 한 번 이상 실행함으로써 수행됨
- 화이트박스 테스트의 검증 기준
    - 문장 검증 기준(Statement Coverage) : 모든 구문이 한 번 이상 수행되도록 진행
    - 분기 검증 기준(Branch Coverage) : 모든 조건문에 대한 조건식의 결과가 True인 경우, False인 경우가 한 번 이상 수행되도록 진행
    - 조건 검증 기준(Condition Coverage) : 조건문에 포함된 개별 조건식의 결과가 True인 경우, False인 경우가 한 번 이상 수행되도록 진행
    - 분기/조건 기준(Branch/Condition Coverage) : 조건문이 True인 경우, False인 경우에 따라 조건 검증 기준의 입력 데이터를 구분하는 테스트

### 7. 프로그래밍 언어 - 출력값 (O)

### 8. 용어 - 템퍼 프루핑(Tamper Proofing) (X)
- 소프트웨어 데이터의 비정상적인 수정이 감지되면 소프트웨어를 오작동하게 만들어 악용을 방지하는 기술
- 해시 함수, 핑거 프린트, 워터마킹 등의 보안 요소를 생성해 소프트웨어에 삽입하고, 실행코드를 난독화하여, 실행 시 원본 비교 및 데이터 확인을 수행함으로써 소프트웨어를 보호하는 기술

### 9. 프로그래밍 언어 - 출력값 (O)

### 10. 용어 - 데이터베이스 구축 과정 (O)
> 요구조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 데이터베이스 구현

### 11. 용어 - 디자인 패턴 (X)
- 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제

#### 생성 패턴 (Creational Pattern) - 클래스나 객체의 생성과 참조 과정 정의
- 추상 팩토리(Abstract Factory)
    - 구체적인 클래스에 의존하지 않음
    - 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
    - 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능
- 빌더(Builder)
    - 작게 분리된 인스턴스를 조합하여 객체생성
    - 객체의 생성과정과 표현방법을 분리해 동일한 객체 생성에서도 서로 다른 결과를 만듦
- 팩토리 메소드(Factory Method)
    - 가상 생성자 패턴
    - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
    - 상위 클래스에서 인터페이스만 정의, 실제 생성을 서브 클래스가 담당
- 프로토타입(Prototype)
    - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
    - 비용이 큰 경우 이용
- 싱글톤(Singleton)
    - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없는 파턴
    - 불필요한 메모리 낭비를 최소화

#### 구조패턴 (Structural Pattern) - 구조가 복잡한 시스템 개발을 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴
- 어댑터(Adapter)
    - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변화해주는 패턴
    - 기존 클래스를 이용하고 싶지만 인터페이스가 일지하지 않을 때 이용
- 브리지(Bridge)
    - 구현부에서 추상층을 분리해 서로가 독립적으로 확장할 수 있도록 구성한 패던
    - 기능과 구현을 두 개의 별도 클래스로 구현
- 프록시(Proxy)
    - 접근이 어려운 객체와 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
    - 네트워크 연결, 메모리의 대용량 객체로의 접근 등 주로 이용

#### 행위패턴 (Behavioral Pattern) - 클래스, 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴
- 인터프리터(Interpreter)
    - 언어에 문법표현을 정의하는 패턴
    - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용
- 중재자(Mediator)
    - 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴
    - 객체 간의 의존성을 줄여 결합도를 감소시킴
    - 객체 간의 통제와 지시의 역할 수행
- 옵서버(Observer)
    - 한 객체의 상태가 변화하면 객체의 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
    - 분산된 시스템 간에 이벤트 생성, 발행하고 이를 수신해야할 때 이용
- 방문자(Visitor)
    - 각 클래스의 데이터 구조에서 처리 기능을 분리해 별도의 클래스로 구성하는 패턴
    - 분리된 처리기능은 각 클래스를 방문하여 수행

### 12. 용어 - 코드방식 (X)
- Hamming
    - 전송 오류를 검출하고 수정
    - 하나의 데이터 단위에 Parity 비트를 추가하여 오류를 검출하여 교정이 하능한 코드
    - 2bit의 오류를 검출할 수 있으며, 1bit의 오류를 교정함
    - 데이터 비트 외의 잉여 비트가 많이 필요하다는 단점 존재
    - FEC에 해당
- FEC
    - 수신측에서 요류를 정정
    - 데이터 전송 과정에서 오류가 발생하면 송신측에 재전송 요구없이 스스로 수정하기 때문에 연속적인 데이터 전송 가능
- BEC
    - 데이터 전송 과정에서 오류가 발생하면 송신측에 재전송을 요구
    - Parity 검사, CRC 등을 통해 오류를 검출하고 ARQ(Automatic Reqeat reQuest)로 오류 제어
- Parity
    - 오류 검사를 위해 데이터 비트 외에 1bit의 체크 비트를 추가하는 것
    - 1bit의 오류만 검출
    - 1의 개수에 따라 짝수 Parity와 홀수 Parity로 나뉨
- CRC
    - 다항식 코드를 사용하여 오류를 검출하는 방식
    - 동기식 전송에서 주로 사용
    - HDLC프레임의 FCS에 사용되는 방식
    - 오류를 검출할 수 있고, 검출률이 높으므로 가장 많이 사용됨

### 13. 용어 - HDLC(High-level Data Link Control) (X)
- 비트(bit) 위주의 프로토콜로, 각 프레임에 데이터 흐름을 제어하고 오류를 검출할 수 있는 비트열을 삽입하여 전송
- 포인트 투 포인트 및 멀티 포인트, 루프 등 다양한 데이터 링크 형태에 동일하게 적용 가능
- HDLC 구조
    - 헤더(플래그, 주소부, 제어부(정보 프레임, 감독 프레임, 비번호 프레임)), 텍스트, 트레일러
- 정보 프레임
    - I 프레임으로 불림
    - 제어부가 '0'으로 시작하는 프레임
    - 사용자 데이터를 전달하거나 피기백킹(Piggybaching) 기법을 통해 데이터에 대한 확인 응답을 보낼 때 사용
- 감독 프레임
    - S 프레임으로 불림
    - 제어부가 '10'로 시작하는 프레임
    - 오류 제어와 흐름제어를 위해 사용
- 비번호 프레임
    - U 프레임으로 불림
    - 제어부가 '11'로 시작하는 프레임
    - 링크와 동작 모드 설정과 관리를 함
    - 표준 응답 모드, 비동기 균형 모드, 비동기 응답 모드

### 14. 프로그래밍 언어 - 출력값 (X)
```
String str1 = "Programming";
String str2 = "Programming";
String str3 = new String("Programming");
```
- str1과 str2는 같은 주소값
- str3은 다른 주소값
- str1 == str2 : true ===> 동일한 주소값
- str1 == str3 : false ===> 다른 주소값
- str1.equals(str3) : true ===> 동일한 값
- str2.equals(str3) : true ===> 동일한 값

### 15. 용어 - 암호화 알고리즘 (X)
- 대칭키 암호화 알고리즘
    - 개인키 암호화 기법
    - 동일한 키로 데이터를 암복호화 하는 기법
    - 암복호화 속도가 빠름
    - 관리해야할 키의 수가 많음
    - 스트림 암호 알고리즘
        - LSFR : 선형 피드백 시프트 레지스터
        - RC4 : 인터넷 보안 프로토콜에서 널리 사용
        - A5 : GSM 통신에서 사용
    - 블록암호 알고리즘
        - DES : 64비트 블록, 56비트키, 16라운드, Feistel 구조
        - 3-DES : 2개의 키, 암호화, 복호화, 암호화, Feistel 구조
        - AES : 128비트 블록, 128/192/256비트키, 10/12/14 라운드, SPN 구조
        - SKIPJACK : 64비트 블록, 128비트키, 32라운드, Feistel 변형
        - IDEA : 64비트 블록, 128비트키, 8라운드, Feistel + SPN 구조(스위스)
        - SEED : 128비트 블록, 128비트키, 16라운드, Feistel 구조(한국)
        - ARIA : 128비트 블록, 128/192/256비트키, 12/14/16라운드, SPN 구조(한국)
        - LEA : 128비트 블록, 128/192/256비트키, 24/28/32라운드, SPN 구조(한국, 경량)
- 비대칭키 암호화 알고리즘
    - 공개키 암호화 기법
    - 암호화 시, 사용하는 공개키는 사용자에게 공개
    - 복호화 시, 비밀키는 관리자가 비밀리에 관리
    - 암복호화 속도가 느림
    - 관리해야할 키의 수가 적음
    - RSA(Rivest Shamir Adleman), ECC
- 해시
    - 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것
    - 일방향 함수
    - SHA 시리즈, HAVAL, MD4, MD5, N-Nash, SNEFRU
    - SHA 시리즈
        - 1993년 미국 국가안보국이 설계, 미국 국립 표준 기술 연구소에 의해 발표
    - MD5 (Message Digest algorithm 5)
        - 1991년 R.Rivest가 MD4를 대체하기 위해 고안한 암호화 해시 함수
        - 블록 크기 : 512 비트
        - 키 길이 : 128 비트
    - N-NASH
        - 1989년 일본의 전신전화주식회사에서 발표한 암호화 해시 함수
        - 블록 크기 & 키 길이 : 128 비트
    - SNEFRU
        - 1990년 R.C.Merkle가 발표한 해시 함수
        - 32비트 프로세서에서 구현을 용이하게 할 목적으로 개발
        - 128비트 및 256비트의 출력을 지원
        - 이집트 파라오의 이름을 따 명명됨
- TKIP (Temporal Key Integrity Protoocl) = WPA
    - 기존의 무선 랜 보안 프로토콜인 WEP의 취약성을 보완한 데이터 보안 프로토콜
    - 암호 알고리즘의 입력 키 길이는 128비트로 늘리고 패킷당 키 할당, 키값 재설정 등의 키 관리 방식을 개선

### 16. 용어 - Hash (O)
- 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것
- 일방향 함수
- SHA 시리즈, HAVAL, MD4, MD5, N-Nash, SNEFRU

### 17. DB - SQL (O)
- CASCADE
    - 제거할 요소를 참조하는 다른 모든 객체를 함께 제거함
- RESTRICT
    - 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소함

### 18. 프로그래밍 언어 - 괄호 (O)

### 19. 프로그래밍 언어 - 출력값 (O)

### 20. 용어 - 테스트 (O)
- 하향식 통합 테스트
    - 프로그램 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법
    - 깊이 우선 통합법, 넓이 우선 통합법 사용
    - 주요 제어 모듈의 종속 모듈들을 스텁(Stub)으로 대체
- 상향식 통합 테스트
    - 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법
    - 하위 모듈들을 클러스터로 결합하며, 상위 모듈에서 데이터의 입·출력을 확인하기 위해 더미 모듈인 드라이버(Driver)를 작성