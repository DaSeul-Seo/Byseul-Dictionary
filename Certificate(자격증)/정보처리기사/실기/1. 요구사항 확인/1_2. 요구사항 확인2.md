## 040. 유스케이스 다이어그램
- UseCase Diagram
- 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것
- 시스템 / 시스템 범위
    - 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현
- 액터(Actor)
    - 시스템과 상호작용하는 모든 외부 요소
    - 주로 사람이나 외부 시스템
    - 주액터 : 시스템을 사용함으로써 이득을 얻는 대상 = 사람
    - 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부시스템 = 조직, 기관
- 유스케이스
    - 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스나 기능 표현
- 관계
    - 포함 : \<\<include\>\>
    - 확장 : \<\<exclude\>\>
    - 일반화 : ◁-
    - 액터와 유스케이스, 유스케이스와 유스케이스 사이 관계 표현

## 041. 유스케이스에서 나타날 수 있는 관계
- 포함(include) 관계
    - 두 개 이상의 유스케이스에서 공통적으로 적용되는 기능을 별도로 분리해 새로운 유스케이스로 만든 경우
    - \<\<include\>\>
- 확장(Exclude) 관계
    - 유스케이스가 특정 조건에 부합되어 유스케이스의 기능이 확장될 때
    - \<\<exclude\>\>

## 042. 활동 다이어그램
- Activity Diagram
- 사용자 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것
- 액션 / 액티비티
    - 액션 : 더 이상 분해할 수 없는 단일 작업
    - 액티비티 : 명 개의 액션으로 분리될 수 있는 작업
- 시작 노드
    - 액션이나 액티비티가 시작됨을 표현
- 종료 노드
    - 액티비티 안의 모든 흐름이 종료됨을 표현
- 조건(판단) 노드
    - 조건에 따라 제어의 흐름이 분리됨을 표현
    - 들어오는 제어 흐름은 한 개, 나가는 제어 흐름은 여러개
- 병합 노드
    - 여러 경로의 흐름이 하나로 합쳐짐을 표현
    - 들어오는 제어 흐름은 여러개, 나가는 제어 흐름은 한 개
- 포크(Fork) 노드
    - 액티비티의 흐름이 분리되어 수행됨을 표현
    - 들어오는 액티비티 흐름은 한개, 나가는 액티비티 흐름은 여러개
- 조인 노드
    - 분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐을 표현
    - 들어오는 액티비티 흐름은 여러개, 나가는 액티비티 흐름은 한 개
- 스윔레인(Swim Lane)
    - 액티비티 수행을 담당하는 주체를 구분하는 선
    - 가로 또는 세로 실선을 구어 구분

## 043. 클래스 다이어그램
- Class Diagram
- 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현
- 클래스
    - 각 객체들이 갖는 속성과 오퍼레이션(동작)을 표현
    - 일반적으로 3개의 구획(Compartment)로 나눠 이름, 속성, 오퍼레이션 표기
    - 속성(Attribute) : 클래스의 상태나 정보를 표현
    - 오퍼레이션(Operation) : 클래스가 수행할 수 있는 동작, 함수 | 메소드
- 제약조건
    - 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야할 조건
    - 클래스 안에 제약조건을 기술할 때는 중괄호({ })
- 관계
    - 클래스와 클래스 사이의 연관성 표현
    - 연관관계, 집합관계, 포함관계, 일반화관계, 의존관계

## 044. 연관 클래스
- 연관관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스

## 045. 시퀀스 다이어그램
- Sequence Diagram
- 시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정을 그림으로 표현
- 액터(Actor)
    - 시스템으로부터 서비스를 요청하는 외부요소 = 사람, 외부시스템
- 객체(Object)
    - 메시지를 주고받는 주체
- 생명선(Lifeline)
    - 객체가 메모리에 존재하는 기간
    - 객체 아래쪽에 점섬을 그어 표현
    - 객체 소명이 표시된 기간까지 존재
- 메시지(Message)
    - 객체가 상호작용을 위해 주고받는 메시지
- 객체 소멸
    - 해당 객체가 더 이상 메모리에 존재하지 않음을 표현
- 프레임(Frame)
    - 다이어그램의 전체 또는 일부를 묶어 표현

## 046. 커뮤니케이션 다이어그램
- Communication Diagram
- 시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정과 객체들 간의 연관을 그림으로 표현
- 액터(Actor)
    - 시스템으로부터 서비스를 요청하는 외부요소 = 사람, 외부시스템
- 객체(Object)
    - 메시지를 주고받는 주체
- 링크(Link)
    - 객체들 간의 관계 표현
    - 액터 & 객체, 객체 & 객체 간 실선
- 메시지(Message)
    - 객체가 상호작용을 위해 주고받는 메시지
    - 일정한 순서에 의해 처리되는 메시지 경우 숫자로 순서 표시

## 047. 상태 다이어그램
- State Diagram
- 객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현
- 상태
    - 객체 상태 표현
- 시작 상태
    - 상태의 시작
- 종료 상태
    - 상태의 종료
- 상태 전환
    - 상태 사이의 흐름, 변화를 화살표로 표현
- 이벤트
    - 상태에 변화를 주는 현상
    - 조건, 외부 신로, 시간의 흐름
- 프레임
    - 상태 다이어그램 범위를 표현

## 048. 패키지 다이어그램
- Package Diagram
- 유스케이스나 클래스 등의 요소들을 그룹화한 패키지 간의 의존관계를 표현
- 패키지(Package)
    - 객체들을 그룹화
    - 단순 표기법 : 패키지 안에 패키지 이름만 표현
    - 확장 표기법 : 패키지 안에 요소까지 표현
- 객체(Object)
    - 유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함될 수 있는 다양한 요소들
- 의존관계(Dependency)
    - 패키지 & 패키지, 패키지 & 객체 간을 점선 화살표로 연결하여 표현
    - 스테레오 타입을 이용해 의존 관계를 구체적으로 표현
    - \<\<import\>\> : 패키지에 포함된 객체들을 직접 가져와서 이용하는 관계
    - \<\<access\>\> : 인터페이스를 통해 패키지 내의 객체에 접근하여 이용하는 관계

## 049. 구조적 방법론
- 정형화된 분석 절차
- 요구사항을 파악하여 문서화하는 처리(Process) 중심의 방법론
- 이해가 쉽고 검증이 가능한 프로그램 코드를 생성하는 것이 목적
- 타당성 검토 → 계획 → 요구사항 → 설계 → 구현 → 시험 → 운용/유지보수

## 050. 객체지향 방법론
- 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 개발시 객체들을 조립해 필요한 SW 구현하는 방법론
- 구조적 기법의 문제점 해결책으로 나온 방법론
- 요구분석 → 설계 → 구형 → 테스트 및 검증 → 인도

## 051. 컴포넌트 기반 방법론
- Component Based Design
- SW를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
- 재사용(Reusavility) 가능
- 시간과 노력을 절감
- 개발 준비 → 분석 → 설계 → 구현 → 테스트 → 전개 → 인도

## 052. 소프트웨어 재사용
- Software Reuse
- 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것
- 합성 중심(Composition-Based)
    - 전자 칩과 같은 SW 부품, 블록을 만들어 끼워 맞춰 SW를 완성시키는 방법
    - 블록 구성 방법
- 생성 중심(Generation-Based)
    - 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법
    - 패턴 구성 방법

## 053. 소프트웨어 재공학
- Software Reengineering
- 기존 시스템을 이용해 보다 나은 시스템을 구축, 새로운 기능을 추가하여 SW 성능 향상시키는 것
- 유지보수 생산성 향상을 통해 SW 위기를 해결하는 방법
- 기존 SW의 데이터와 기능들의 개조 및 개선을 통해 유지보수성과 품질 향상

## 054. CASE
- Computer Aided Software Engineering
- 소프트웨어 개발과정에서 사용되는 과정 전체 또는 일부를 컴퓨터와 전용 SW 도구를 사용해 자동화 하는것
- CASE 주요기능
    - SW 생명주기 전 단계 연결
    - 다양한 소프트웨어 개발 모형 지원
    - 그래픽 지원

## 055. 하향식 비용 산정 기법
- 과거의 유사한 경험을 바탕으로 전문지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 방법
- 전문가 감정 기법 : 조직 내에 있는 경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법
- 델파이 기법 : 전문가 감정 기법의 주관적인 편경을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법

## 056. 상향식 비용 산정 기법
- 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법
- 주요 상향식 비용 산정 기법
    - LOC(원시 코드 라인 수) 기법
    - 개발 단계별 인월수 기법
    - 수학적 산정 기법

## 057. LOC 기법
- source Line Of Code
- 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용해 비용을 산정하는 기법

## 058. 수학적 산정 기법
- 상향식 비용 산정 기법
- 경험적 추정 모형, 실험적 추정 모형
- 개발 비용 산정의 자동화를 목표
- 주요 수학적 산정 기법
    - COCOMO 모형
    - Putnam 모형
    - 기능 점수(FP) 모형

## 059. COCOMO 모형
- COnstructive COst MOdel
- LOC에 의한 비용 산정 기법
- LOC를 예측한 후 SW 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용 산정
- 비용 산정 결과는 Man-Month로 나타냄
- Boehm 제안

## 060. COCOMO의 소프트웨어 개발 유형
1\) 조직형(Organic Mode)
- 중 · 소규모의 SW
- 일괄 자료 처리, 과학기술 계산용, 비즈니스 자료 처리용 등 5만(50KDSI)라인 이하
- 사무 처리용, 업무용, 과학용 응용 소프트웨어 개발에 적합

2\) 반분리형(Semi-Detached Mode)
- 조직형과 내장형의 중간형 SW
- 트랜잭션 처리 시스템이나 운영체제, DBMS 등의 30만(300KDSI)라인 이하
- 컴파일러, 인터프리터와 같은 유틸리티 개발에 적합

3\) 내장형(Embedded Mode)
- 초대형 규모 SW
- 트랜책션 처리 시스템이나 운영체제 등의 30(300KDSI) 라인 이상
- 신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적합

## 061. Putnam 모형
- SW 생명주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형
- 생명 주기 예측 모형
- 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 함

## 062. 기능 점수 모형
- FUnctional Point
- SW의 기능을 증대시키는 요인별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능 점수를 산출
- 기능 점수와 영향도를 이용해 기능 점수를 구한 후 비용을 산정하는 기법
- SW 기능 증대 요인
    - 자료 입력(입력 양식)
    - 정보 출력(출력 보고서)
    - 명령어(사용자 질의수)
    - 데이터 파일
    - 필요한 외부 루틴과의 인터페이스

## 063. 비용 산정 자동화 추정 도구
- SLIM
    - Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 도구
- ESTIMACS
    - 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구

## 064. PERT
- Program Evaluation and Review Technique, 프로그램 평가 및 검토 기술
- 전체 작업의 상호관계를 표시하는 네트워크
- 종료시기를 결정하는 것
    - 낙관적인 경우
    - 가능성이 있는 경우
    - 비관적인 경우

## 065. CPM
- Critical Path Method, 임계 경로 기법
- 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법
- 노드와 간선으로 구성된 네트워크로 노드는 작업, 간선은 작업 간의 전후 의존 관계를 나ㅏ냄
- 임계경로 = 최장 경로

## 066. 간트차트
- 작업 일정을 막대 도표를 이용해 표시하는 프로젝트 일정표
- 시간선(Time-Line) 차트
- 중간 목표 미달성 시 그 이유와 기간을 예측할 수 있음

## 067. ISO/IEC 12207
- ISO(국제표준화기구)에서 만든 표준 SW 생명주기 프로세스
- 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 SW 생명주기 표준을 제공
- 기본 생명주기 프로세스 : 획득, 공급, 개발, 운영, 유지보수 프로세스
- 지원 생명주기 프로세스 : 품질 보증, 검증, 확인 활동 검토, 감사, 문서화, 형상관리, 문제해결 프로세스
- 조직 생명주기 프로세스 : 관리, 기반 구조, 훈련, 개선 프로세스

## 068. CMMI
- Capability Maturity Model Integration
- SW 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델
- 초기(Initial) : 작업자 능력에 따라 성공 여부 결정
- 관리(Managed) : 특정 프로젝트 내의 프로세스 정의 및 구현
- 정의(Defined) : 조직의 표준 프로세스를 활용하여 업무 수행
- 정량적 관리(Quantitativelt Managed) : 프로젝트를 정량적으로 관리 및 통제
- 최적화(Optimizing) : 프로세스 역량 향상을 위해 지속적인 프로세스 개선

## 069. SPICE
- Software Process Improvement and Capability dEtermination
- SW 품질 및 생산성 향상을 위해 SW 프로세스를 평가 및 개선하는 국제 표준
- ISO/IEC 15504

## 070. SPICE 프로세스 수행 능력 단계
0\) 불완전(Incomplete)
- 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계

1\) 수행(Performed)
- 프로세스가 수행되고 목적이 달성된 단계

2\) 관리(Managed)
- 정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계

3\) 확립(Estabished)
- SW 공학 원칙에 기반하여 정의된 프로세스가 수행되는 관계

4\) 예측(Predictable)
- 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해 일관되게 수행되는 관계

5\) 최적화(Optimizing)
- 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계

## 071. 소프트웨어 개발 방법론 테일러링
- SW 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업
- 고려사항
    - 내부적 기준
        - 목표환경 : 시스템 개발환경과 유형이 서로 다른 경우
        - 요구사항 : 개발, 운영, 유지보수 등 프로젝트 우선적으로 고려할 요구사항이 서로 다른 경우
        - 프로젝트 규모 : 비용, 인력, 기간 등 프로젝트의 규모가 서로 다른 경우
        - 보유 기술 : 프로세스, 개발 방법론, 산출물, 구성원의 능력 등이 서로 다른 경우
    - 외부적 기준
        - 법적 제약사항 : 프로젝트별로 적용될 IT Compliance가 서로 다른 경우
        - 표준 품질 기준 : 금융, 제도 등 분야별 표준 품질 기준이 서로 다른 경우

## 072. 소프트웨어 개발 프레임워크
- SW 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 구현할 수 있도록 여러 가지 기능들을 제공해주는 반제품 형태의 소프트웨어 시스템
- 사업자 종속성 해소

## 073. 스프링 프레임워크
- Spring Framework
- 자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크
- 동적인 웹 사이트 개발을 위해 다양한 서비스 제공
- 전자정부 표준 프레임워크 기반 기술

## 074. 소프트웨어 개발 프레임워크 특성
- 모듈화(Modularity)
    - 캡슐화를 통해 모듈화 강화하고 설계 및 구형의 변경에 따른 형향 최소화 -> SW 품질 향상
    - 유지보수 용이
- 재사용성(Reusability)
    - 재사용 가능한 모듈 제공
    - 예산 절감, 생산성 향상, 품질 보증 가능
- 확장성(Extensibility)
    - 다형성(Polymorphism)을 통한 인터페이스 확장 가능
    - 다양한 형태와 기능을 가진 애플리케이션 개발 가능
- 제어의 역흐름(Inversion of Control)
    - 개발자가 관리하고 통제해야하는 객체들의 제어를 프레임워크에 넘김으로써 생산성 향상












# Reference
- 정보처리기사 실기 (시나공)