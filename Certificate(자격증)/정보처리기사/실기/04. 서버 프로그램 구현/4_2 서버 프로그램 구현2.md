## 190. 모듈
- 모듈화를 통해 분리된 시스템의 각 기능
- 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업단위
- 논리적인 기능을 수행하기 위한 명령어들의 집합
- 모듈의 독립성을 결합도와 응집도에 의해 측정

## 191. 결합도
- Coupling
- 모듈 간의 상호 의존하는 정도
- 모듈 사이의 연관관계
- 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음

## 192. 결합도 종류
![copling](../img/coupling.png)

1\) 자료 결합도 (Data Coupling)
- 모듈 간 인터페이스가 자료 요소로만 구성될 때
- 모듈이 다른 모듈을 호출하면서 매개변수로 데이터를 넘겨주고, 결과를 다시 돌려주는 방식
- 모듈의 내용을 변경하더라도 다른 모듈에 전혀 영향을 미치지 않는 가장 바람직한 결합도

2\) 스탬프(검인) 결합도 (Stamp Coupling)
- 모듈 간 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때
- 두 모듈이 동일한 자료 구조를 조회하는 경우
- 자료 구조의 변화(포맷이나 구조 변화) 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈에까지도 영향을 미침

3\) 제어 결합도 (Control Coupling)
- 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어요소(Function Code, Switch, Tag, Flag)를 전달
- 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우
- 처리 기능이 두 모듈에 분리되어 설계된 경우

4\) 외부 결합도 (External Coupling)
- 모듈에 선언된 데이터(변수)를 외부의 다른 모듈에서 참조할 때
- 참조되는 데이터의 범위를 각 모듈에서 제한

5\) 공통(공유) 결합도 (Common Coupling)
- 공통 데이터 영역을 여러 모듈이 사용할 때
- 내용을 조금만 변경하더라도 이를 사용하는 모든 모듈에 영향을 미치므로 모듈의 독립성을 약하게 만듬
- 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용해 전역 변수를 갱신하는 방식으로 상호작용

6\) 내용 결합도 (Content Coupling)
- 모듈이 다른 모듈의 내부 기능 및 내부 자료를 직접 참조하거나 수정할 때
- 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우에도 내용 결합도에 해당

## 193. 응집도
- Cohesion
- 모듈 내부 요소들이 서로 관련이 있는 정도
- 응집도가 강할수록 품질이 높고, 약할수록 품직이 낮음

## 194. 응집도 종류
![cohesion](../img/cohesion.png)

1\) 우연적 응집도 (Coincidental Cohesion)
- 모듈 내부의 각 구성요소들이 서로 관련 없는 요소로만 구성된 경우

2\) 논리적 응집도 (Logical Cohesion)
- 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우

3\) 시간적 응집도 (Temporal Cohesion)
- 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우

4\) 절차적 응집도 (Procedural Cohesion)
- 모듈이 다수의 관련 기능을 가질 때, 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우

5\) 교환(통신)적 응집도 (Communication Cohesion)
- 동일한 입력과 출력을 사용해 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우

6\) 순차적 응집도 (Sequential Cohesion)
- 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우

7\) 기능적 응집도 (Functional Cohesion)
- 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우

## 195. 팬인/팬아웃
- Fan-In : 어떤 모듈을 제어하는 모듈
- Fan-Out : 어떤 모듈에 의해 제어되는 모듈

## 196. N-S 차트
- Nassi-Schneiderman Chart
- 논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법
- GOTO나 화살표 사용 X
- 제어 논리 구조
    - 연속, 선택 및 다중 선택, 반복
- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합

## 197. 단위 모듈
- Unit Module
- 한 가지 동작을 수행하는 기능을 모듈로 구현한 것
- 하나의 기능을 단위 기능
- 독립적인 컴파일 가능
- 다른 모듈에 호출되거나 삽입됨
- 단위 모듈의 구현 과정
    - 단위 기능 명세서 작성 → 입 · 출력 기능 구현 → 알고리즘 구현

## 198. IPC
- Inter-Process Communication
- 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
- 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현 가능
- 메소드 5가지
    - 공유 메모리(Shared Memory)
    - 소켁(Socket)
    - 세마포어(Semaphores)
    - 파이프와 네임드 파이프(Pipes & named Pipes)
    - 메시지 큐잉(Message Queueing)

## 199. 테스트 케이스
- SW가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서
- 식별자 : 항목 식별자, 일련번호
- 테스트 항목 : 테스트 대상(모듈 또는 기능)
- 입력 명세 : 테스트 데이터 또는 테스트 조건
- 출력 명세 : 테스트 케이스 수행 시 예상되는 출력 결과
- 환경설정 : 필요한 하드웨어나 소프트웨어의 환경
- 특수 절차 요구 : 테스트 케이스 수행 시 특별히 요구되는 절차
- 의존성 기술 : 테스트 간의 의존성

## 200. 공통 모듈 명세 기법의 종류
- 여러 프로그램에서 공통으로 사용할 수 있는 모듈
- 정확성(Correctness) : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
- 명확성(Clarity) : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성
- 완전성(Completeness) : 시스템 구현을 위해 필요한 모든 것을 기술
- 일관성(Consistency) : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
- 추적성(Traceability) : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성함

## 201. 재사용
- Reuse
- 이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화
- 비용과 시간 절약
- 이해할 수 있고 사용 가능하도록 사용법 공개
- 규모에 따른 분류
    - 함수와 객체 : 클래스나 메소드 단위의 소스코드 재사용
    - 컴포넌트 : 컴포넌트 자체에 대한 수정없이 인터페이스를 통해 통신하는 방식으로 재사용
    - 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용

## 202. 코드의 주요 기능
- 자료의 분류, 조합, 집계, 추출을 용이하게 하기 위해 사용하는 기호
- 식별 기능 : 데이터 간의 성격에 따라 구분 가능
- 분류 기능 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화
- 배열 기능 : 의미를 부여하여 나열
- 표준화 기능 : 다양한 데이터를 기준에 맞추어 표현
- 간소화 기능 : 복잡한 데이터를 간소화

## 203. 코드의 종류
1\) 순차 코드(Sequence Code)
- 자료의 발생 순서, 크기 순서 등 일정 기준에 따라 최초의 자료부터 차례로 일련번호를 부여하는 방법
- 1, 2, 3, 4...

2\) 블록 코드(Block Code)
- 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법
- 구분 코드
- 1001 ~ 1100:총무부, 1101 ~ 1200:영업부

3\) 10진 코드(Decimal Code)
- 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 10진 분할하는 방법을 필요한 만큼 반복하는 방법
- 도서 분류식 코드
- 1000:공학, 1100:소프트웨어 공학, 1110:소프트웨어 설계

4\) 그룹 분류 코드(Group Classification Code)
- 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 그룹 안에서 일련번호를 부여하는 방법
- 1-01-001:본사-총무부-인사계, 2-01-001:지사-총무부-인사계

5\) 연상 코드(Mnemonic Code)
- 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용해 코드를 부여하는 방법
- TV-40:40인치 TV, L-15-220:15W 220V의 램프

6\) 표의 숫자 코드(Significant Digit Code)
- 코드화 대상 항목의 성질(길이, 넓이, 부피, 지름, 높이 등)의 물리적 수치를 그대로 코드에 적용시키는 방법
- 유효 숫자 코드
- 120-720-1500:두께X폭X길이가 120X720X1500인 강판

7\) 합성 코드(Combined Code)
- 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법
- 연상코드 + 순차코드
- KE-711:대한한공 711기, AC-253:에어캐나다 253기

## 204. 디자인 패턴
- Design Pattern
- 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성
- 생성 패턴, 구조 패턴, 행위 패턴

## 205. 생성 패턴
- Creational Pattern
- 클래스나 객체의 생성과 참조 과정 정의

1\) 추상 팩토리 (Abstract Factory)
- 구체적인 클래스에 의존하지 않음
- 인터페이스를 통해 서로 연관 · 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
- 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능

2\) 빌더 (Builder)
- 작게 분리된 인스턴스를 조합하여 객체생성
- 객체의 생성과정과 표현방법을 분리해 동일한 객체 생성에서도 서로 다른 결과를 만듦

3\) 팩토리 메소드 (Factory Method) = 가상 생성자 패턴 (Virtual Constructor Pattern)
- 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
- 상위 클래스에서 인터페이스만 정의, 실제 생성을 서브 클래스가 담당

4\) 프로토타입 (Prototype)
- 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
- 일반적인 방법
- 비용이 큰 경우 이용

5\) 싱글톤 (Singleton)
- 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없다.
- 클래스 내에서 인스턴스가 하나뿐임을 보장
- 불필요한 메모리 낭비 최소화

## 206. 구조패턴
- Structural Pattern
- 구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴

1\) 어댑터 (Adapter)
- 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변화해주는 패턴
- 기존 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용

2\) 브리지 (Bridge)
- 구현부에서 추상층을 분리해 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 기능과 구현을 두 개의 별도 클래스로 구현

3\) 컴포지트 (Composite)
- 여러 객체를 가진 복합 객체와 단일 객체를 구분없이 다루고자 할 때 사용하는 패턴
- 객체들을 트리구조로 구성하여 복합객체 안에 복합객체가 포함되는 구조를 구현

4\) 데코레이터 (Decorator)
- 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
- 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식

5\) 퍼싸드 (Facade)
- 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 서브 클래스 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요

6\) 플라이웨이트 (Flyweight)
- 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 공유해서 사용함으로써 메모리를 절약하는 패턴
- 다수 유사 객체를 생성하거자 조작할 때 유용

7\) 프록시 (Proxy)
- 접근이 어려운 객체와 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
- 네트워크 연결, 메모리의 대용량 객체로의 접근 등 주로 이용

## 207. 행위 패턴
- Behavioral Pattern
- 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

1\) 책임 연쇄 (Chain of Responsibility)
- 요청을 처리할 수 있는 객체가 둘 이상 존재해 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
- 요청을 처리할 수 있는 객체들이 고리로 묶여있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감

2\) 커맨드 (Command)
- 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
- 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화 함

3\) 인터프리터 (Interpreter)
- 언어에 문법 표현을 정의하는 패턴
- SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용

4\) 반복자 (Iterator)
- 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
- 내부 표현 방법의 노출없이 순차적인 접근 가능

5\) 중재자 (Mediator)
- 구많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴
- 객체 사이의 의존성을 줄여 결합도를 감소시킴
- 객체 간의 통제와 지시의 역할을 수행

6\) 메멘토 (Memento)
- 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
- Ctrl + z와 가은 되돌리기 기능을 개발할 떄 주로 이용

7\) 옵서버 (Observer)
- 한 객체의 상태가 변화하면 객체의 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
- 분산된 시스템 간에 이벤트를 생성 · 발행하고, 이를 수신해야할 때 이용

8\) 상태 (State)
- 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- 객체 상채를 캡슐화하고 이를 참조하는 방식

9\) 전략 (Strategy)
- 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호교환할 수 있게 정의하는 패턴
- 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향없이 알고리즘의 변경 가능

10\) 탬플릿 메소드 (Template Method)
- 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
- 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌

11\) 방문자 (Visitor)
- 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
- 불리된 처리기능은 각 클래스를 방문하여 수행

## 208. 서버 개발 프레임워크
- 다양한 네트워크 설정, 요청 및 응답 처리, 아키텍처 모델 구현 등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어
- MVC 패턴 기반으로 개발
- Spring, Node.js, Django, Codeigniter, Ruby on Rails

## 209. 서버 개발 프레임워크 종류
- Spring
    - Java 기반으로 만든 프레임워크
    - 전자정부 표준 프레임워크의 기반 기술로 사용
- Node.js
    - JavaScript 기반으로 만든 프레임워크
    - 비동기 입 · 출력 처리와 이벤트 위주의 높은 처리 성능을 갖고 있어 실시간으로 입 · 출력이 빈번한 애플리케이션에 적합
- Django
    - Python을 기반으로 만든 프레임워크
    - 컴포넌트 재사용과 플러그인화를 강조하여 신속한 개발이 가능하도록 지원
- Codeigniter
    - PHP 기반으로 만든 프레임워크
    - 인터페이스가 간편하며 서버 자원을 적게 사용
- Ruby on Rails
    - Ruby 기반으로 만든 프레임워크
    - 테스트를 위한 웹 서버를 지원하며 데이터베이스 작업을 단순화, 자동화시켜 개발 코드의 길이가 짧아지게 함으로써 신속한 개발이 가능

## 210. 서버 개발 과정
- DTO/VO 구현 : 데이터 교환을 위해 사용할 객체를 만드는 과정
- SQL 구현 : 데이터 삽입, 변경, 삭제 등의 작업을 수행할 SQL문을 생성하는 과정
- DAO 구현 : DB에 접근하고, SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정
- Service 구현 : 사용자의 요청에 응답하기 위한 로직을 구현하는 과정
- Controller 구현 : 사용자의 요청에 적절한 서비스를 호출하여, 결과를 사용자에게 반환하는 코드를 구현하는 과정

## 211. API
- Application Programming Interface
- 라이브러리를 이용할 수 있도록 규칙 등을 정의해 놓은 인터페이스
- 다양한 기능을 손쉽게 이용할 수 있도록 도와 효율적인 개발 가능
- Open API : 누구나 무료로 사용할 수 있게 공개된 API

## 212. 배치 프로그램
- Batch Program
- 여러 작업들을 미리 정해진 일련의 순서에 따라 일관적으로 처리하도록 만든 프로그램
- 대용량 데이터 : 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함
- 자동화 : 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입없이 수행되어야 함
- 견고성 : 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일없이 수행되어야 함
- 안정성/신뢰성 : 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함
- 성능 : 다른 응용 프로그램의 수행을 방해하지 않아야하며, 지정된 시간 내에 처리가 완료되어야 함

## 213. 배치 스케줄러
- Batch Scheduler
- 일괄처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구
- 스프링 배치(Spring Batch)
    - Spring Source 사와 Accenture 사가 2007년 공동 개발한 오픈 소스 프레임워크
    - 로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등의 다양한 기능 제공
- Quartz
    - 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄처리를 위한 다양한 기능을 제공하는 오픈소스 라이브러리
    - 수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일괄처리 작업에 유연성을 제공
- Cron
    - 리눅스의 기본 스케줄러 도구
    - crontab 명령어를 통해 작업을 예약

## 214. crontab 명령어 작성 방법
- 분, 시, 일, 월, 요일에 "*"를 입력하면 매 시기마다 수행



# Reference
- 정보처리기사 실기 (시나공)