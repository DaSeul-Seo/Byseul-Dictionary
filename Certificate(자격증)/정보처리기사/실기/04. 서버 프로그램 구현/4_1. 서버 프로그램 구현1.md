## 159. 개발 환경 구축
- 개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것
- 개발 환경은 운영될 환경과 유사한 구조로 구축
- 하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등의 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축

## 160. 하드웨어 환경
- 클라이언트(Client)
    - 사용자와의 인터페이스 역할
    - PC, 스마트 폰
- 서버(Server)
    - 클라이언트와 통신하여 서비스 제공
    - 웹 서버(Web Server)
    - 웹 애플리케이션 서버(WAS; Web Application Server)
    - 데이터베이스 서버(DB Server)
    - 파일 서버(File Server)

## 161. 소프트웨어 환경
- 시스템 소프트웨어
    - 클라이언트와 서버 운영
    - 운영체제(OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램
    - DBMS
- 개발 소프트웨어
    - 개발
    - 요구사항 관리 도구
    - 설계/모델링 도구
    - 구현 도구
    - 빌드 도구
    - 테스트 도구
    - 형상관리 도구

## 162. 웹 서버의 기능
- HTTP/HTTPS 지원 : 브라우저로부터 요청을 받아 응답할 떄 사용되는 프로토콜
- 통신 기록(Coomunication Log) : 처리한 요청들을 로그 파일로 기록하는 기능
- 정적 파일 관리(Managing Static Files) : HTML, CSS, 이미지 등 정적 파일 저장하고 관리하는 기능
- 대역폭 제한(Bandwidth Throttling) : 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능
- 가상 호스팅(Virtual Hosting) : 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능
- 인증(Authentication) : 사용자가 합법적인 사용자인지 확인하는 기능

## 163. 개발 언어의 선정 기준
- 적정성 : 개발하려는 소프트웨어의 목적에 적합해야 함
- 효율성 : 코드의 작성 및 구현이 효율적이어야 함
- 이식성 : 다양한 시스템 및 환경에 적응이 가능해야 함
- 친밀성 : 개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 함
- 범용성 : 다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 함

## 164. 소프트웨어 아키텍처
- 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
- 애플리케이션 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 결정
- 모듈화, 추상화, 단계적 분해, 정보 은닉

## 165. 모둘화
- Modularity
- 시스템 기능들을 모듈 단위로 나누는 것
- SW 성능 향상, 시스템 수정 및 재사용, 유지관리
- 모듈 간 결합도(Coupling) 최소화
- 모듈 내 요소들의 응집도(Cohesion) 최대화

## 166. 추상화
- Abstraction
- 전체적이고 포괄적인 개념을 설계한 후 세분화하여 구체화 시켜 나가는 것
- 과정 추상화 : 자세한 수행 과정을 정의하기 않고, 전반적인 흐름만 파악할 수 있게 설꼐
- 자료 추상화 : 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
- 제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법

## 167. 단계적 분해
- Stepwise Refinement
- 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
- Niklaus Wirth에 의해 제안
- 하향식 설계 전략
- 포괄적인 기능부터 점차적으로 구체화하고, 알고리즘, 자료구조 등 상세 내역을 가능한 뒤로 미뤄 진행

## 168. 정보 은닉
- Information Hiding
- 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
- 모듈을 독립적으로 수행
- 하나 모듈이 변경되더라도 다른 모듈에 영향을 주지 않음
- 수정, 시험, 유지보수 용이

## 169. 상위 설계와 하위 설계
- 상위 설계
    - 아키텍처 설계, 예비 설계
    - 시스템의 전체적인 구조
    - 구조, DB, 인터페이스
- 하위 설계
    - 모듈 설계, 상세 설계
    - 시스템의 내부 구조 및 행위
    - 컴포넌트, 자료 구조, 알고리즘

## 170. 소프트웨어 아키텍처의 품질 속성
- 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성
- 비즈니스 측면 : 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정
- 아키텍처 측면 : 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성

## 171. 협약(Contract)에 의한 설계
- 컴포넌트 설계 시, 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것
- 선행 조건(Precondition) : 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
- 결과 조건(Postcondition) : 오퍼레이션이 수행된 후 만족되어야 할 조건
- 불변 조건(Invariant) : 오퍼레이션이 실행되는 동안 항상 만족되어야할 조건

## 172. ⭐ 아키텍처 패턴
- 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
- 기본적인 윤곽 제시
- 서브시스템과 그 역할이 정의됨
- 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴

## 173. ⭐ 레이어 패턴
- Layers Pattern
- 시스템을 계층으로 구분하여 구성 → 고전적인 패턴
- 하위계층은 상위계층에 대한 서비스 제공자
- 상위계층은 하위계층의 클라이언트
- 마주보는 두 개의 계층 사이에만 상호작용
- OSI 참조 모델

## 174. ⭐ 클라이언트-서버 패턴
- Client-Server Pattern
- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
- 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에게 제공

## 175. ⭐ 파이프-필터 패턴
- Pipe-Filter Pattern
- 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송
- 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후, 결과물은 다시 파이프를 통해 다음 시스템으로 넘겨주는 패컨
- 데이터 변환, 버퍼링, 동기화
- Shell

## 176. 모델-뷰-컨트롤러 패턴
- Model-View-Controller Pattern
- 서브시스템을 모델, 뷰, 컨트롤러로 구조화
- 컨트롤러가 사용자 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용해 뷰에 정보를 출력
- 여러 개의 뷰 생성
- 한 개의 모델에 대한 여러 뷰를 필요로 하는 대화형 애플리케이션에 적합

## 177. ⭐ 기타 패턴
- 마스터-슬레이브 패턴(Master-Slave Pattern)
    - 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식
    - 장애 허용 시스템, 병렬 컴퓨팅 시스템
- 브로커 패턴(Broker Pattern)
    - 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결
    - 분산 환경 시스템
- 피어-투-피어 패턴(Pear-To-Pear Pattern)
    - 피어 컴포넌트가 클라이언트가 될수도, 서버가 될 수도 있는 패턴
    - 파일 공유 네트워크
- 이벤트-버스 패턴(Event-Bus Pattern)
    - 소스가 특정 채널에 이벤트 메시지를 발행(Publish)하면, 해당 채널을 구독(Subscribe)한 리스너(Listener)들이 메시지를 받아 이벤트를 처리하는 패턴
    - 알림 서비스
- 블랙보드 패턴(Blackboard Pattern)
    - 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근 가능한 패턴
- 인터프리터 패턴(Interpreter Pattern)
    - 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴
    - 번역기, 컴파일러, 인터프리터

## 178. 객체지향
- Object-Oriented
- 소프트웨어의 각 요소들을 객체(Object)로 만든 후 객체들을 조립해서 소프트웨어를 개발하는 기법
- 구성요소
    - 객체
    - 클래스
    - 메시지
- 특징
    - 캡슐화
    - 상속
    - 다형성
    - 연관성

## 179. 객체
- Object
- 데이터와 이를 처리하기 위한 함수를 묶어놓은 소프트웨어 모듈
- 데이터
    - 객체가 가지고 있는 정보
    - 속성, 상태, 분류
- 함수
    - 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘
    - 객체의 상태를 참조하거나 변경하는 수단

## 180. 클래스
- Class
- 공통된 속성과 연산을 갖는 객체의 집합
- 객체들이 갖는 속성과 연산을 정의하고 있는 틀
- 인스턴스(Instance) : 클래스에 속한 객체

## 181. 메시지
- 객체의 동작이나 연산을 일으키는 외부 요구사항
- 대응하는 연산을 수행하여 예상된 결과 반환

## 182. 캡슐화
- Encapsulation
- 외부에서 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉
- 외부 모듈의 변경으로 인한 파급 효과가 적음
- 객체 간 메시지를 주고받을 때 상대 객체의 세부 내용을 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아짐

## 183. 상속
- Inheritance
- 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
- 하위 클래스는 물려받은 속성과 연산을 다시 정의하지 않아도 즉시 자신의 속성으로 사용 가능
- 하위 클래스는 상속받은 속성과 연산 외의 새로운 속성과 연산을 첨가하여 사용 가능

## 184. 다형성
- Polymorphism
- 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
- 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질
- 객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함

## 185. 연관성
- Relationship
- 두 개 이상의 객체들이 상호 참조하는 관계
- is member of
    - 연관화(Association)
    - 2개 이상의 객체가 상호 관련되어 있음
- is instance of
    - 분류화(Classfication)
    - 동일한 형의 특성을 갖는 객체들을 모아 구성
- is part of
    - 집단화(Aggregation)
    - 관련 있는 객체들을 묶어 하나의 상위 객체를 구성
- is a
    - 일반화(Generalization) : 공통적인 성질들로 추상화한 상위 객체를 구성
    - 특수화/상세화(Specialization) : 상위 객체를 구체화하여 하위 객체를 구성

## 186. 객체지향 분석
- OOA; Object Oriented Analysis
- 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업
- 객체 & 속성, 클래스 & 멤버, 전체 & 부분 등으로 나누어서 분석
- 클래스를 식별하는 것

## 187. ⭐ 객체지향 분석 방법론
- Rumbaugh(럼바우) 방법
    - 분석활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행
- Booch(부치) 방법
    - 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용
    - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
- Jacobson 방법
    - 유스케이스를 강조하여 사용
- Coad와 Yourdon 방법
    - E-R 다이어그램을 사용하여 객체의 행위를 모델링
    - 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구상
- Wirfs-Brock 방법
    - 분석과 설계 간의 구분이 없음
    - 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행

## 188. ⭐ 럼바우의 분석 기법
- 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링
- 객체 모델링 기법(OMT; Object-Modeling Technique)
- 객체 모델링 → 동적 모델링 → 기능 모델링
- 객체 모델링(Object Modeling)
    - 정보 모델링(Information Modeling)
    - 시스템에서 요구되는 객체를 찾아 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시
- 동적 모델링(Dynamic Modeling)
    - 상태 다이어그램을 이용
    - 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현
- 기능 모델링(Functional Modeling)
    - 자료 흐름도(DFD)를 이용해 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현

## 189. ⭐ 객체지향 설계 원칙(SOLID 원칙)
- 단일 책임 원칙(SRP) : 객체는 단 하나의 책임만 가져야 함
- 개방-폐쇄 원칙(OCP) : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 함
- 리스코프 치환 원칙(LSP) : 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 함
- 인터페이스 분리 원칙(ISP) : 자신이 사용하지 않는 인터페이스와 의존관계를 맺거나 영향을 받지 않아야 함
- 의존 역전 원칙(DIP) : 의존 관계 설립 시 추상성이 높은 클래스와 의존관계를 맺어야 함


# Reference
- 정보처리기사 실기 (시나공)