## ⭐ 서브쿼리
- 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문

```SQL
SELECT p.id
      ,p.name
      ,p.price
      ,( SELECT a.name
         FROM artists a
         WHERE a.id = p.artist_id ) AS artist_name
FROM paintings p;
```

### 서브쿼리 사용 시 주의사항
- 괄호로 감싸서 사용
- 단일행 또는 복수행 비교 연산자와 함께 사용 가능
    - 단일행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하여야 하며, 복수행 비교 연산자는 서브쿼리의 결과 건수와 상관없음
- 서브쿼리엔 ORDER BY 사용 불가 **(ORDER BY 절에서 사용 가능)**
    - ORDER BY절은 SELECT절에서 오직 한 개만 올 수 있음
    - ORDER BY는 메인쿼리의 마지막 문장에 위치해야 함
    - 예외: TOP-N분석
- 서브쿼리는 쿼리 안에 포함된 또 다른 쿼리로, 메인쿼리를 보조하는 하위 쿼리
- 다양한 위치에서 사용될 수 있다.
    - SELECT절에서 특정 값을 계산하여 반환
    - FROM절에서 마치 테이블처럼 사용되어 서브쿼리의 결과를 임시 테이블로 취급
    - WHERE절에서 조건을 지정하는데 사용

### 서브쿼리가 위치할 수 있는 곳
- SELECT, FROM, WHERE, HAVING, ORDER BY 절 **[GROUP BY 불가]**
- 기타 DML: INSERT문의 VALUES절, UPDATE문의 SET절

### 동작 방식에 따른 서브쿼리 분류
- 연관 서브쿼리 (Correlated Subquery)
    - 서브쿼리가 메인쿼리의 컬럼을 가짐
- 비연과 서브쿼리(Un-Correlated Subquery)
    - 서브쿼리가 메인쿼리의 컬럼을 가지지 않음

#### ⭐ 목적
- 연관 서브쿼리
    - 일반적으로 메인쿼리가 먼저 수행되어 읽은 데이터를 서브쿼리에서 조건이 맞는지 확인할 때 사용
- 비연관 서브쿼리
    - 메인쿼리에 서브쿼리가 실행된 결과값을 제공하기 위한 목적으로 주로 사용
- 즉, 메인쿼리의 결과가 서브쿼리로 제공될 수 있고, 서브쿼리의 결과가 메인쿼리로 제공될 수 있음
    - 실행 순서는 상황에 따라 다르다는 것

### 반환되는 데이터 형태에 따른 서브쿼리 분류
- 단일행 서브쿼리
    - 서브쿼리의 실행 결과가 항상 1건 이하
    - 단일행 비교 연산자와 함께 사용 (=, <, <=, >, >=, <>)
    - 다중행 비교 연산자고 사용 가능
- 다중행 서브쿼리
    - 서브쿼리의 실행 결과가 여러 건인 서브쿼리
    - 다중행 비교 연산자와 함께 사용(IN, ALL, ANY, SOME, EXISTS)
    - 단일행 비교 연산자 사용 불가능
- 다중컬럼 서브쿼리
    - 서브쿼리의 실행 결과로 여러 컬럼 반환
    - 주로 메인쿼리의 조건과 비교하기 위해 사용
        - 비교하고자 하는 컬럼의 개수와 위치가 동일해야 함

### 위치에 따른 서브쿼리 분류
#### ① 스칼라 서브쿼리 (Scalar Subquery)
- SELECT절에 사용하는 서브쿼리
- 서브쿼리가 단일행, 단일열을 반환
- **서브쿼리의 결과를 하나의 열처럼 사용**하기 위해 사용

```SQL
SELECT * | 컬럼명 | 표현식,
    (SELECT * | 컬럼명 | 표현식
     FROM 테이블명/뷰명
     WHERE 조건)
FROM 테이블명/뷰명;
```

#### paintins 테이블
|id|name|artist_id|price|
|---|---|---|---|
|101|숲과 나|1|1,100,000|
|102|반의 도시|1|1,350,000|
|103|파도|2|470,000|
|104|Pop!|3|750,000|
|105|너|4|640,000|
|106|밤 비|5|920,000|
|107|기억|5|380,000|

#### artists 테이블
|id|name|
|---|---|
|1|이지현|
|2|황현석|
|3|박성진|
|4|백예서|
|5|정하나|

```SQL
SELECT p.id, p.name, p.price,
        (SELECT a.name
         FROM artists a
         WHERE a.id = p.artist_id) AS artist_name
FROM paintings p;
```

|id|name|price|artist_name|
|---|---|---|---|
|101|숲과 나|1,100,000|이지현|
|102|반의 도시|1,350,000|이지현|
|103|파도|470,000|황현석|
|104|Pop!|750,000|박성진|
|105|너|640,000|백예서|
|106|밤 비|920,000|정하나|
|107|기억|380,000|정하나|

- 각 작품의 번호, 이름, 가격과 그 작품에 대한 작가 정보를 가져오기
- **메인 쿼리의 각 행에 대해 하나의 단일값(예술가 이름)을 반환**
- 스칼라 서브쿼리는 OUTER JOIN연산을 사용한 결과와 같다.


```SQL
-- 같은 결 과 반환
SELECT p.id, p.name, p.price, a.name
FROM paintings p
LEFT JOIN artists a
ON p.artist_id = a.id
```

⭐ **매칭되는 데이터가 없는 경우 해당 컴럼에 대한 값은 NULL로 표현(생략되는 것이 아님)**

|id|name|price|artist_name|
|---|---|---|---|
|101|숲과 나|1,100,000|이지현|
|102|반의 도시|1,350,000|이지현|
|103|파도|470,000|황현석|
|104|Pop!|750,000|박성진|
|105|너|640,000|백예서|
|106|밤 비|920,000|정하나|
|107|기억|380,000|정하나|
|**108**|**여행**|**150,000**|**NULL**|

```SQL
-- EX) 부서번호가 10번인 각 직원의 이름과 사번, 부서본호, 부서이름 출력
SELECT EMPNO, ENAME, DEPTNO,
        (SELECT DNAME
         FROM DEPT D
         WHERE D.DEPTNO = E.DEPTNO) AS DNAME
FROM EMP E
WHERE DEPTNO 10;
```

```SQL
-- EX) 사원, 직원이름, 부서번호, 급여, 총 급여 출력
SELECT EMPNO, ENAME, DEPTNO, SAL,
        (SELECT SUM(SAL)
         FROM EMP) AS TOTAL_SAL
FROM EMP;
```

- 원래 SUM 함수는 집계함수로 각 행들의 값을 하나의 값으로 요약하는 함수이기에 다른 컬럼과 함께 SELECT 절에 올수 없다. 하지만 서브쿼리를 통해 단일값으로 가져와 각 직원정보의 행마다 4번째 컬럼값으로 넣어줄 수 있다.

#### ② 인라인 뷰 (Inline View) = 동적 뷰(Dynamic View)
- FROM절에 사용하는 서브쿼리
    - **중첩 서브쿼리와 다르게 서브쿼리의 결과를 메인 쿼리의 어느 절에서도 사용 가능**
- **서브쿼리의 결과를 테이블처럼 사용**하기 위해 사용
- 뷰(View)처럼, 쿼리 내에서 임시적으로 생성된 결과를 테이블처럼 사용할 수 있다.
    - 쿼리를 실행할 때만 존재하며 데이터베이스에 저장되지 않는다. => 일회성
- 다른 테이블과 조인 시 반드시 **테이블 별칭을 명시**해야 함

```SQL
SELECT * | 컬럼명 | 표현식,
FROM (SELECT * | 컬럼명 | 표현식
      FROM 테이블명/뷰명)
WHERE 조건;
```

```SQL
-- EX) 각 작가의 평균 수입보다 높은 가격인 그림들의 목록
SELECT p.artist_id, p.name, p.price, p2.avg_price
FROM PAINTINGS p,
    (SELECT artist_id, AVG(price) AS avg_prive
     FROM PAINTINGS
     GROUP BY artist_id) p2
WHERE p.artist_id = p2.artist_id
AND p.price > p2.avg_price;
```

#### 💡 인라인 뷰의 실행 원리/순서
① 서브쿼리(인라인뷰)
- 서브쿼리가 각 작가별 평균 작품의 가격을 계산
- 계산된 결과는 다중행, 다중컬럼을 가진 일종의 테이블
- **WHERE절에서 조인을 해야하므로 서브쿼리의 결과는 무조건 별칭을 가져야 함**

② FROM
- PAINTINGS 테이블 p와 서브쿼리로부터 받은 임시테이블 p2를 조인
- 두 테이블 사이에 명확한 JOIN 조건이 존재하지 않아 Caresian Product 생성

③ WHERE
- p.artist_id = p2.artist_id인 데이터 찾기
- p.price > p2.avg_price를 만족하는 행을 필터링

④ SELECT
- 최종적으로 SELECT절에서 선택한 행들만 반환

|artist_id|name|price|avg_price|
|---|---|---|---|
|1|밤의 도시|1,350,000|1,225,000|
|5|밤 비|920,000|650,000|

#### 💡 조인을 명시해주었다면
- 조인의 종류를 명시하면 불필요한 조합이 생성되지 않는다.
```SQL
SELECT p.artist_id, p.name, p.price, p2.avg_price
FROM paintings p
INNER JOIN (
    SELECT artist_id, AVG(price) AS avg_price
    FROM paintings
    GROUP BY artist_id) p2
ON p.artist_id = p2.artist_id
WHERE p.price > p2.avg_price;
```

```SQL
-- EX) 2020년에 입사한 사원들의 정보와 각 사원들의 부양가족 수 조회
SELECT E.사원번호, E.사원면, D.부서번호, D.부서명,
    (SELECT COUNT(*)
     FROM 부양가족 F
     WHERE F.사원번호 = E.사원번호) AS 부양가족수
FROM 부서 D, (SELECT *
             FROM 사원
             WHERE 입사년도 = '2020') E
WHERE D.부서번호 = E.부서번호
```

#### 💡 스칼라 서브쿼리와의 차이
- 스칼라 서브쿼리는 단일 값을 반환해야 하므로 하나의 컬럼만 선택할 수 있으며, 메인쿼리의 각 행마다 독립적으로 실행된다.
- 인라인 뷰는 테이블 형태의 결과를 반환해야 하므로 메인쿼리에서 필요한 컬럼들이 서브쿼리 안에 포함되어야 한다.
- 메인쿼리에서 조인할 때, 서브쿼리로부터 얻은 임시 테이블의 컬럼이 필요하니 반드시 해당 쿼리는 인라인 뷰안에 명시되어야 한다.
- 인라인 뷰에서 집계함수를 사용하고 해당 결과 값을 메인쿼리의 조건절인 WHERE절에 사용해야 한다면 별칭을 무조건 정해주어야 한다.
    - WHERE 절에는 집계함수를 사용할 수 없으니까

#### ③ 중첩 서브쿼리 (Nested Subquery)
- WHERE절이나 HAVING절과 같은 조건절에서 쓰이는 서브쿼리
- **메인쿼리의 데이터를 필터링하거나 비교할 때 사용**
- 반환 데이터의 형태가 여러 가지(단일, 다중, 다중컬럼, 연관/비연관)

```SQL
SELECT * | 컬럼명 | 표현식,
FROM 테이블명/뷰명
WHERE 조건연산자 (SELECT * | 컬럼명 | 표현식
                 FROM 테이블명/뷰명
                 WHERE 조건);
```

① 반환종류 : 단일행 서브쿼리
- 서브쿼리 결과로 1개의 행이 반환
- 단일행 비교연산자: =, <>, >, >=, <, <=

```SQL
-- EX) 평균 본급보다 높은 봉급을 가진 직원의 사번, 이름, 봉급 출력
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL > (SELECT AVG(SAL)
             FROM EMP);
```

```SQL
-- EX) 강감찬 소속 팀에 소속된 팀의 선수들 정보 출력
SELECT PLAYER_NAME, POSITION, BACK_NO
FROM PLAYER
WHERE TEAM_ID = (SELECT TEAM_ID
                 FROM PLAYER
                 WHERE PLAYER_NAME = '강감찬')
```

② 반환종류: 다중행 서브쿼리
- 서브쿼리의 결과로 여러 행이 반환

|다중행 비교 연산자|설명|
|---|---|
|IN|결과에 값이 포함되는지 확인|
|ANY|결과 중 하나라도 조건을 만족하는지|
|ALL|모든 값이 조건을 만족하는지|
|EXISTS|결과가 존재하는지 여부를 확인|

|연산자|설명|비교|
|---|---|---|
|> ANY|최소값 반환|> ANY(10,200) : 최소값(10)보다 큰 행들 반환|
|< ANY|최대값 반환|< ANY(10,200) : 최대값(200)보다 작은 행들 반환|
|> ALL|최대값 반환|> ANN(10,200) : 최대값(200)보다 큰 행들 반환|
|< ALL|최소값 반환|< ALL(10,200) : 최소값(10)보다 작은 행들 반환|

```SQL
-- EX) 10번 부서의 사원들의 봉급 중 최소 봉급보다 많이 받는 사원 정보 조회
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL > ANY(SELECT SAL
                FROM EMP
                WHERE DEPTNO = 10);
```

③ 반환종류 : 다중컬럼 서브쿼리 (SQL Server 지원X)
- 서브쿼리의 결과로 여러 개의 컬럼이 반환
- 메인쿼리의 비교 컬럼이 2개 이상인 경우
- 대소 비교 전달 불가(두 값을 동시에 묶어서 대소비교할 수 없으니)

```SQL
-- EX) 부서별 최대 급여자들의 정보 출력
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
                        FROM EMP
                        GROUP BY DEPTNO);
```

```SQL
-- EX) 소속팀별 키가 가장 작은 사람들의 정보 출력
SELECT TEAM_ID, PLAYER_NAME, HEIGHT
FROM PLAYER
WHERE (TEAM_ID, HEIGHT) IN (SELECT TEAM_ID, MIN(HEIGHT)
                            FROM PLAYER
                            GROUP BY TEAM_ID);
```

④ 반환종류 : 상호연관 서브쿼리
- 메인쿼리와 서브쿼리의 비교 수행
- 서브쿼리 내에 메인쿼리의 컬럼이 사용됨
- 비교할 집단이나 조건은 서브쿼리에 명시
    - 메인쿼리절엔 서브쿼리 컬럼이 정의되어 있지 않으니 오류 발생

#### EX) 부서별 해당 부서의 평균급여보다 높은 급여를 받는 사원 정보
```SQL
-- 오류 쿼리 : 다중 컬럼 서브쿼리는 두 컬럼에 대해 동시 대소비교 불가능
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) > (SELECT DEPTNO, AVG(SAL)
                        FROM EMP
                        GROUP BY DEPTNO);

-- 정상 : 대소비교할 컬럼을 메인쿼리에 두고, 일치조건은 서브쿼리에 전달
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP E1
WHERE SAL > (SELECT AVG(SAL)
             FROM EMP E2
             WHERE E1.DEPTNO = E2.DEPTNO
             GROUP BY DEPTNO);
```
- 메인쿼리와 결과적으로 비교해야 할 컬럼은 SAL, DEPTNO인데, 그 중 SAL에 대한 대소비교 전에 먼저 비교할 DEPTNO가 확정되어야 함
- 먼저 비교할 DEPTNO값을 서브쿼리에 전달
- 메인쿼리에는 서브쿼리의 테이블 정보가 없으므로 메인쿼리에 E.DEPTNO = D.DEPTNO조건은 사용불가

#### 💡 상호연관 서브쿼리의 연산 순서
① 메인쿼리의 테이블 READ

② 메인쿼리의 WHERE절 확인

③ 서브쿼리 테이블 READ

④ 서브쿼리 WHERE 절 확인

⑤ E1.DEPTNO와 서브쿼리의 DEPTNO와 비교

⑥ 위 조건에 성립하는 행들의 그룹연산 결과 확인(AVG(SAL))

⑦ 해당 결과를 메인쿼리에 전달해 해당 조건을 만족하는 행만 추출

#### 💡 상호연관 서브쿼리 사용 시 GROUP BY 생략 가능
```SQL
SELECT a.name AS artist_name
FROM artists a
WHERE a.id = (
    -- 비상관 서브쿼리 : 메인쿼리의 컬럼을 갖지 X
    SELECT p.artist_id
    FROM paintings p
    WHERE p.price = (SELECT MAX(price) FROM paintings)
);


SELECT p.id, p.name, p.price, a.name AS artist_name
FROM paintings p
JOIN artists a ON p.artist_id = a.id
WHERE p.price > (
    -- 상관 서브쿼리 : 메인쿼리의 컬럼을 갖음
    SELECT AVG(p2.price)
    FROM paintings p2
    WHERE p2.artist_id = p.artist_id
);
```

### 서브쿼리 사용시 주의사항2
- 조인할 테이블의 기본키가 2개 이상이라면 WHERE절에서 조인(=)에 사용되는 기본키에도 두 키를 모두 사용해줘야 한다.

```SQL
-- 주문 항목을 저장하는 테이블
CREATE TABLE order_items(
    order_id INT,
    product_id INT,
    quantity INT,
    price DECIMAL(10, 2),
    PRIMARY KEY (order_id, product_id)
);

SELECT a.order_id, a.product_id,
       a.quantity, a.price,
       (SELECT SUM(b.quantity * b.price)
        FROM order_items b
        WHERE b.order_id = a.order_id
        AND b.product_id = a.product_id) AS total_amount
FROM order_items a;
```

### HAVING절에서 서브쿼리
- 그룹함수와 함께 사용될 때, 그룹필된 결과에 대해 부가 조건을 걸기 위해 사용

### UPDATE문의 SET절에서 서브쿼리
- **서브쿼리를 사용한 변경 작업을 할때, 서브쿼리 결과가 NULL을 반환하면 해당 컬럼 결과가 NULL이 될 수 있기 때문에 주의**

### NOT EXISTS와 서브쿼리
- WHERE문에 NOT EXISTS는 서브쿼리 테이블의 결과물을 제외한 나머지를 메인쿼리에 출력
- 메인쿼리에서 서브쿼리의 결과물이랑 겹치는 애들은 제외(차집합)

### EXISTS와 서브쿼리
- WHERE문에 EXISTS는 서브쿼리 테이블의 결과물과 겹치는 데이터만 메인쿼리에 출력

## 집합 연산자
### 집합 연산자
- SELECT문 결과를 하나의 집합으로 간주
    - 그 집합에 대한 합집합, 교집합, 차집합의 연산
- **두 집합의 각 컬럼의 순서와 데이터 타입이 상호 호환 가능해야 함**
- **전체 집합의 컬럼명과 데이터 타입은 첫 번째 집합에 의해 결정됨**
- 두 집합 사이에 집합 연산자 정의
- 두 개 이상의 테이블에서 JOIN을 사용하지 않고, 연관된 데이터를 조회하는 방법

### 합집합 (UNION, UNION ALL)
- 두 집합의 합집합

① UNION
- **중복된 데이터는 한 번만 출력**
- 중복된 데이터를 제거하기 위해 내부적으로 정렬 수행
    - 따라서 추가적인 연산을 하지 않게 하기 위해, 중복된 데이터가 없을 경우 UNION ALL을 사용하는게 좋음

```SQL
-- 스윗홈 시즌 1,2 출연 배우 모두 조회(중복은 한 번만)
SELECT 배역명, 본명 FROM sweethome1
UNION
SELECT 배역명, 본명 FROM sweethome2;
```

② UNION ALL
- **중복된 데이터를 제거하지 않고 모든 행 반환**

```SQL
-- 스윗홈 시즌 1,2 출연 배우 모두 조회(중복 괜찮음)
SELECT 배역명, 본명 FROM sweethome1
UNION
SELECT 배역명, 본명 FROM sweethome2;
```

### 교집합 (INTERSECT - 중복제거)
- 두 집합의 공통으로 있는 행 출력
```SQL
-- 스윗홈 시즌1,2에 모두 출연한 배우 조회
SELECT 배역명, 본명 FROM sweethome1
INTERSECT
SELECT 배역명, 본명 FROM sweethome2;
```

### 차집합 (ORACLE: MINUS) EXCEPT
- 두 집합 중 한 쪽 집합에만 존재하는 행 출력
- **(A-B)와 (B-A)는 다르니 집합의 순서에 주의**
```SQL
-- 시즌 1에는 출연했으나 시즌 2에는 출연하지 않은 배우 조회
SELECT 배역명, 본명 FROM sweethome1
MINUS
SELECT 배역명, 본명 FROM sweethome2;

-- 시즌 2에는 출연했으나 시즌 1에는 출연하지 않은 배우 조회
SELECT 배역명, 본명 FROM sweethome2
MINUS
SELECT 배역명, 본명 FROM sweethome1;
```

### 집합 연산자 사용시 주의사항
① 두 집합의 컬럼 수가 일치해야 함

② 두 집합의 컬럼 순서 일치해야 함 (오류가 발생하지는 않음)

③ 두 집합의 각 컬럼의 데이터 타입이 상호 호환 가능해야 함

④ 각 컬럼의 사이즈는 달라도 됨

⑤ **개별 SELECT문에 ORDER BY 불가(GROUP BY는 가능)**
- 아래 집합의 ORDER BY는 집합 연산자 전체 결과에 대한 ORDER BY로 적용됨
    - 1:1의 테이블 관계
        - EXCEPT 결과는 항상 공집합
        - INTERSECT와 JOIN 연산의 결과는 같다.
        - INTERSECT와 UNION의 결과는 같다.
        - UNION ALL 수행 시 결과는 한 테이블의 전체 건수에 2배가 된다. (UNION 수행 시 결과 건수는 같음)
    - 1:N의 테이블 관계
        - INTERSECT보다 JOIN의 연산 결과 수가 더 많다.

## 그룹 함수
### ANSI/ISO SQL 표준 데이터 분석을 위한 세 가지의 함수
- AGGREGATE FUNCTION 집계 함수
- GROUP FUNCTION 그룹 함수
- WINDOW FUNCTION 윈도우 함수

### AGGREGATE 집계함수 (⭐NULL값 무시)
① COUNT
- 행의 수를 세는 함수
- 모든 데이터 타입에 사용가능
- 대상 컬럼은 * 또는 단 하나의 컬럼
    - ⭐해당 컬럼의 값이 NULL인 경우 COUNT 제외
- PK 컬럼의 경우 NULL일 수 없으니 전체 행의 수를 세고 싶을 때는 PK컬럼이나 NOT NULL 컬럼을 사용하는 것이 좋음

② SUM
- 총 합 출력
- 숫자 컬럼에만 사용가능

③ AVG
- 평균 출력
- 숫자 컬럼에만 사용가능
- **NULL을 제외한 대상의 평균을 반환하니 전체 대상 평균 연산 시 주의**

```SQL
AVG(SAL)
SUM(SAL) / COUNT(EMPNO) -- empno : PK
AVG(NVL(SAL,0))
```
- 전체 10명,  그 중 NULL 값을 5명이 가졌다면 AVG()는 5명에 대한 평균을 계산하게 된다.
- 전체 평균을 구하고 싶으면 SUM() / COUNT(NOT NULL 컬럼)이나 NVL(SAL, 0)로 NULL값을 0으로 바꾼 후 구하면 된다.

④ MIN / MAX
- 최소 / 최대 출력
- 날짜, 숫자, 문자 컬럼에 모두 사용 가능

⑤ VARIANCE / STDDEV
- 분산과 표준편차 (분산의 루트값)

### ⭐ GROUP FUNCTION 그룹함수
```SQL
-- 부서별 업무별 사원수와 급여 합 조회
SELECT DNAME, JOB,
        COUNT(*) "Total Empl",
        SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME, JOB;
```
- 별도의 그룹함수를 GROUP BY 절에 적지 않을 경우 소계나 총 합계가 따로 생성되지 않는다.
- GROUP BY절 사용시 자동 정렬이 수행되지 않으니, 정렬이 필요한 경우엔 ORDER BY절에 명시적으로 정렬 컬럼을 표시해야 한다.

① ROLLUP 함수
```SQL
SELECT DNAME, JOB,
        COUNT(*) "Total Empl"
        SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB)
ORDER BY DNAME, JOB;
```
|DNAME|JOB|Total Empl|Total Sal|
|---|---|---|---|
|ACCOUNTING|CLERK|1|1300|
|ACCOUNTING|MANAGER|1|2450|
|ACCOUNTING|PRESIDENT|1|5000|
|ACCOUNTING||3|8750|
|RESEARCH|ANALYST|2|6000|
|RESEARCH|CLERK|2|1900|
|RESEARCH|MANAGER|1|2975|
|RESEARCH||5|10875|
|SALES|CLERK|1|950|
|SALES|MANAGER|1|2850|
|SALES|SALESMAN|4|5600|
|SALES||6|9400|
|||14|29025|


- 그룹핑하는 컬럼의 수가 N일 시 N + 1 Level의 Subtotal(소계)가 생성된다.
- **ROLLUP의 인수는 계층 구조라 인수 순서가 바뀌면 수행 결과도 바뀐다.**
- GROUPING COLUMNS인 DNAME과 JOB에 대한 다음과 같은 추가 LEVEL의 집계가 생성되었다.
    - L1 : GROUP BY 수행 시 생성되는 표준 집계 (9건)
    - L2 : DNAME 별 모든 JOB의 SUBTOTAL (3건)
    - L3 : GRAND TOTAL (마지막 행, 1건)
- UNION ALL로 대체 가능
```SQL
-- DNAME과 JOB별 그룹 연산
SELECT DNAME, JOB,
        COUNT(*) AS "Total Empl",
        SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME, JOB
UNION ALL
-- DNAME별 그룹 연산(소계)
SELECT DNAME, NULL AS JOB,
        COUNT(*) AS "Total Empl",
        SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME
UNION ALL
-- 전체 총계
SELECT NULL AS DNAME, NULL AS JOB,
        COUNT(*) AS "Total Empl",
        SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
ORDER BY DNAME, JOB;
```

#### 💡 ROLLUP 인수의 순서를 바꾼다면
```SQL
SELECT NVL(species, '합계') AS species,
        NVL(breed, '합계') AS breed,
        ROUND(AVG(age), 2) AS 평균_나이
FROM ANIMAL_HOTAL
GROUP BY ROLLUP(specied, breed);
```
|specied|breed|평균_나이|
|---|---|---|
|강아지|말티즈|6|
|강아지|비숑 프리제|5|
|강아지|시바견|1|
|강아지|치와와|2|
|강아지|포메라니안|3|
|강아지|푸들|6.5|
|강아지|합계|4.56|
|고양이|러시안블루|2|
|고양이|샴|3.33|
|고양이|스코티쉬 폴드|5|
|고양이|아비시니안|2|
|고양이|페르시안|5.67|
|고양이|합계|4|
|토끼|네덜란드 드워프|2|
|토끼|라이언헤드|3|
|토끼|미니렉스|2|
|토끼|홀랜드 롭|4|
|토끼|합계|2.67|
|합계|합계|3.88|


```SQL
SELECT NVL(species, '합계') AS species,
        NVL(breed, '합계') AS breed,
        ROUND(AVG(age), 2) AS 평균_나이
FROM ANIMAL_HOTAL
GROUP BY ROLLUP(breed, specied);
```
|specied|breed|평균_나이|
|---|---|---|
|토끼|네덜란드 드워프|2|
|합계|네덜란드 드워프|2|
|토끼|라이언헤드|3|
|합계|라이언헤드|3|
|고양이|러시안블루|2|
|합계|러시안블루|2|
|강아지|말티즈|6|
|합계|말티즈|6|
|토끼|미니렉스|2|
|합계|미니렉스|2|
|강아지|비숑 프리제|5|
|합계|비숑 프리제|5|
|...|...|...|
|합계|합계|3.88|

#### ROLLUP 함수에 결합 컬럼 사용
- ROLLUP 함수 사용시 괄호로 묶은 JOB과 MGR의 경우, **하나의 집합 (JOB + MGR)컬럼으로 간주**하여 괄호 내 각 컬럼별 집계를 구하지 않는다.

```SQL
SELECT DNAME, JOB, MGR, SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP (DNAME, (JOB, MGR));
```
|DNAME|JOB|MGR|Total Sal|
|---|---|---|---|
|SALES|CLERK|7698|950|
|SALES|MANAGER|7839|2850|
|SALES|SALESMAN|7698|5600|
|SALES|||9400|
|RESEARCH|CLERK|7788|1100|
|RESEARCH|CLERK|7902|800|
|RESEARCH|ANALYST|7566|6000|
|RESEARCH|MANAGER|7839|2975|
|RESEARCH|||10875|
|ACCOUNTING|CLERK|7752|1300|
|ACCOUNTING|MANAGER|7839|2450|
|ACCOUNTING|PRESIDENT||5000|
|ACCOUNTING|||8750|
||||29025|

#### ⭐ GROUPING 함수
- 그룹 함수를 지원하기 위한 함수로 ROLLUP이나 CUBE에 의한 소계가 계산된 결과에는 GROUPING(컬럼) = 1이 표시되고, 그 외 결과에는 GROUPING(컬럼) = 0이 표시된다.

```SQL
-- NVL 대신 GROUPING 함수 이용해서 NULL 값 다른 값으로 대체하기
SELECT CASE WHEN GROUPING(DNAME) = 1
            THEN 'All Departments'
            ELSE DNAME END AS DNAME,
       CASE WHEN GROUPING(JOB) = 1
            THEN 'All Jobs'
            ELSE JOB END AS JOB,
       COUNT(*) AS "Total Empl",
       SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB);

-- DECODE를 사용해도 같은 결과
SELECT
DECODE(GROUPING(DNAME), 1, 'All Departments', DNAME) AS DNAME,
DECODE(GROUPING(JOB), 1, 'All Jobs') AS JOB,
COUNT(*) AS "Total Empl",
SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB);
```

|DNAME|JOB|Total Empl|Total Sal|
|---|---|---|---|
|SALES|CLERK|1|950|
|SALES|MANAGER|1|2850|
|SALES|SALESMAN|4|5600|
|SALES|All Jobs|6|9400|
|RESEARCH|CLERK|2|1900|
|RESEARCH|ANALYST|2|6000|
|RESEARCH|MANAGER|1|2975|
|RESEARCH|All Jobs|5|10875|
|ACCOUNTING|CLERK|1|1300|
|ACCOUNTING|MANAGER|1|2450|
|ACCOUNTING|PRESIDENT|1|5000|
|ACCOUNTING|All Jobs|3|8750|
|All Departments|All Jobs|14|29025|

② CUBE 함수
- 결합 가능한 모든 값에 대하여 다차원 집계 생성
    - **그룹핑되는 컬럼이 가질 수 있는 모든 경우에 대해 소계를 생성**
    - ROLLUP에 비해 시스템에 많은 부담이 생기니 사용에 주의
- ROLLUP과 달리 인수들 간의 간 계층 구조가 아니라 평등한 관계라 **인수의 순서가 바뀌어도 정렬 순서는 바뀔 수 있어도 데이터의 결과는 같다.**
- CUBE(DNAME, JOB)이나 CUBE(JOB, DNAME)이나 같은 결과 도출

```SQL
SELECT DNAME, JOB
    COUNT(*) "Total Empl"
    SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY CUBE(DNAME, JOB);
```

|DNAME|JOB|Total Empl|Total Sal|
|---|---|---|---|
|||14|29025|
||CLERK|4|4150|
||ANALYST|2|6000|
||MANAGER|3|8275|
||SALESMAN|4|5600|
||PRESIDENT|1|5000|
|SALES||6|9400|
|SALES|CLERK|1|950|
|SALES|MANAGER|1|2850|
|SALES|SALESMAN|4|5600|
|RESEARCH||5|10875|
|RESEARCH|CLERK|2|1900|
|RESEARCH|ANALYST|2|6000|
|RESEARCH|MANAGER|1|2975|
|ACCOUNTING||3|8750|
|ACCOUNTING|CLERK|1|1300|
|ACCOUNTING|MANAGER|1|2450|
|ACCOUNTING|PRESIDENT|1|5000|

- GROUP BY ROLLUP(DNAME, JOB)에서는 JOB별 소계는 생성되지 않았지만 CUBE에서는 JOB별 소계도 생성된다.
- 전체 총계도 물론 생성
- ROLLUP과 마찬가지로 UNION ALL을 통해서 표현할 수 있으며, ROLLUP과 달리 JOB컬럼에 대한 소계가 추가되므로 인수가 2개일 경우 총 4개의 SELECT문이 UNION되어야 한다.

③ GROUPING SETS 함수
- CUBE와 마찬가지로 **인수별로 평등한 관계를 가져 컬럼의 나열 순서는 중요하지 않다.**
- ROLLUP과 CUBE와 달리 자동으로 총계가 출력되지 않는다.
    - GROUP BY GROUPING SETS(A,B,())나 GROUP BY GROUPING SETS(A,B, NULL)로 A소계, B소계, 총계 이렇게 총계까지 출력되게 할 수 있다.

```SQL
SELECT DNAME, JOB,
        COUNT(*) "Total Empl",
        SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY GROUPING SETS(DNAME, JOB);
```

|DNAME|JOB|Total Empl|Total Sal|
|---|---|---|---|
||CLERK|4|4150|
||SLAESMAN|4|5600|
||PRESIDENT|1|5000|
||MANAGER|3|8275|
||ANALYST|2|6000|
|ACCOUNTING||3|8750|
|RESEARCH||5|10875|
|SALES||6|9400|

- GROUPING SETS의 경우 인수로 받은 각 컬럼별 소계가 생성된다.
- UNION ALL로 대체 가능

```SQL
-- DNAME별 소계
SELECT DNAME, NULL AS JOB,
        COUNT(*) "Total Empl",
        SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME
UNION ALL
-- JOB별 소계
SELECT NULL AS DNAME, JOB,
        COUNT(*) "Total Empl",
        SUM(SAL) "Total SaL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY JOB;
```

#### ROLLUP / CUBE / GROUPING SETS
<table>
    <thead style="text-align:center">
        <tr>
            <td>표현식</td>
            <td>출력값</td>
            <td>순서 무관</td>
        </tr>
    </thead>
    <tbody style="text-align:center">
        <tr>
            <td>ROLLUP(A, B)</td>
            <td>A와 B별 소계 / A별 소계 / 총계</td>
            <td>X (계층 구조)</td>
        </tr>
        <tr>
            <td>CUBE(A, B)</td>
            <td>A와 B별 소계 / A별 소계 / B별 소계 / 총계</td>
            <td rowspan="2">O (평등 관계)</td>
        </tr>
        <tr>
            <td>GROUPING SETS(A, B)</td>
            <td>A별 소계 / B별 소계</td>
        </tr>
    </tbody>
</table>

- 세 함수 모두 결과 정렬이 필요한 경우 ORDER BY절에 정렬 컬럼을 명시해야 한다.
- CUBE와 ROLLUP함수 모두 GROUPING SETS 함수로 대체 가능하다.

```SQL
-- ROLLUP 이용
SELECT DEPNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

-- GROUPING SETS로
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS((DEPTNO, JOB), DEPTNO, ());
```
```SQL
-- CUBE 이용
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB);

-- GROUPING SETS로
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB, (DEPTNO, JOB), ());
```


<br />

📖 Reference
- [2024 개념정리](https://bruders.tistory.com/)


