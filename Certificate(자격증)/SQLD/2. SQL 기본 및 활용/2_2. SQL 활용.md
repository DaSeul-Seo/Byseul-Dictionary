## ⭐ 서브쿼리
- 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문

```SQL
SELECT p.id
      ,p.name
      ,p.price
      ,( SELECT a.name
         FROM artists a
         WHERE a.id = p.artist_id ) AS artist_name
FROM paintings p;
```

### 서브쿼리 사용 시 주의사항
- 괄호로 감싸서 사용
- 단일행 또는 복수행 비교 연산자와 함께 사용 가능
    - 단일행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하여야 하며, 복수행 비교 연산자는 서브쿼리의 결과 건수와 상관없음
- 서브쿼리엔 ORDER BY 사용 불가 **(ORDER BY 절에서 사용 가능)**
    - ORDER BY절은 SELECT절에서 오직 한 개만 올 수 있음
    - ORDER BY는 메인쿼리의 마지막 문장에 위치해야 함
    - 예외: TOP-N분석
- 서브쿼리는 쿼리 안에 포함된 또 다른 쿼리로, 메인쿼리를 보조하는 하위 쿼리
- 다양한 위치에서 사용될 수 있다.
    - SELECT절에서 특정 값을 계산하여 반환
    - FROM절에서 마치 테이블처럼 사용되어 서브쿼리의 결과를 임시 테이블로 취급
    - WHERE절에서 조건을 지정하는데 사용

### 서브쿼리가 위치할 수 있는 곳
- SELECT, FROM, WHERE, HAVING, ORDER BY 절 **[GROUP BY 불가]**
- 기타 DML: INSERT문의 VALUES절, UPDATE문의 SET절

### 동작 방식에 따른 서브쿼리 분류
- 연관 서브쿼리 (Correlated Subquery)
    - 서브쿼리가 메인쿼리의 컬럼을 가짐
- 비연과 서브쿼리(Un-Correlated Subquery)
    - 서브쿼리가 메인쿼리의 컬럼을 가지지 않음

#### ⭐ 목적
- 연관 서브쿼리
    - 일반적으로 메인쿼리가 먼저 수행되어 읽은 데이터를 서브쿼리에서 조건이 맞는지 확인할 때 사용
- 비연관 서브쿼리
    - 메인쿼리에 서브쿼리가 실행된 결과값을 제공하기 위한 목적으로 주로 사용
- 즉, 메인쿼리의 결과가 서브쿼리로 제공될 수 있고, 서브쿼리의 결과가 메인쿼리로 제공될 수 있음
    - 실행 순서는 상황에 따라 다르다는 것

### 반환되는 데이터 형태에 따른 서브쿼리 분류
- 단일행 서브쿼리
    - 서브쿼리의 실행 결과가 항상 1건 이하
    - 단일행 비교 연산자와 함께 사용 (=, <, <=, >, >=, <>)
    - 다중행 비교 연산자고 사용 가능
- 다중행 서브쿼리
    - 서브쿼리의 실행 결과가 여러 건인 서브쿼리
    - 다중행 비교 연산자와 함께 사용(IN, ALL, ANY, SOME, EXISTS)
    - 단일행 비교 연산자 사용 불가능
- 다중컬럼 서브쿼리
    - 서브쿼리의 실행 결과로 여러 컬럼 반환
    - 주로 메인쿼리의 조건과 비교하기 위해 사용
        - 비교하고자 하는 컬럼의 개수와 위치가 동일해야 함

### 위치에 따른 서브쿼리 분류
#### ① 스칼라 서브쿼리 (Scalar Subquery)
- SELECT절에 사용하는 서브쿼리
- 서브쿼리가 단일행, 단일열을 반환
- **서브쿼리의 결과를 하나의 열처럼 사용**하기 위해 사용

```SQL
SELECT * | 컬럼명 | 표현식,
    (SELECT * | 컬럼명 | 표현식
     FROM 테이블명/뷰명
     WHERE 조건)
FROM 테이블명/뷰명;
```

#### paintins 테이블
|id|name|artist_id|price|
|---|---|---|---|
|101|숲과 나|1|1,100,000|
|102|반의 도시|1|1,350,000|
|103|파도|2|470,000|
|104|Pop!|3|750,000|
|105|너|4|640,000|
|106|밤 비|5|920,000|
|107|기억|5|380,000|

#### artists 테이블
|id|name|
|---|---|
|1|이지현|
|2|황현석|
|3|박성진|
|4|백예서|
|5|정하나|

```SQL
SELECT p.id, p.name, p.price,
        (SELECT a.name
         FROM artists a
         WHERE a.id = p.artist_id) AS artist_name
FROM paintings p;
```

|id|name|price|artist_name|
|---|---|---|---|
|101|숲과 나|1,100,000|이지현|
|102|반의 도시|1,350,000|이지현|
|103|파도|470,000|황현석|
|104|Pop!|750,000|박성진|
|105|너|640,000|백예서|
|106|밤 비|920,000|정하나|
|107|기억|380,000|정하나|

- 각 작품의 번호, 이름, 가격과 그 작품에 대한 작가 정보를 가져오기
- **메인 쿼리의 각 행에 대해 하나의 단일값(예술가 이름)을 반환**
- 스칼라 서브쿼리는 OUTER JOIN연산을 사용한 결과와 같다.


```SQL
-- 같은 결 과 반환
SELECT p.id, p.name, p.price, a.name
FROM paintings p
LEFT JOIN artists a
ON p.artist_id = a.id
```

⭐ **매칭되는 데이터가 없는 경우 해당 컴럼에 대한 값은 NULL로 표현(생략되는 것이 아님)**

|id|name|price|artist_name|
|---|---|---|---|
|101|숲과 나|1,100,000|이지현|
|102|반의 도시|1,350,000|이지현|
|103|파도|470,000|황현석|
|104|Pop!|750,000|박성진|
|105|너|640,000|백예서|
|106|밤 비|920,000|정하나|
|107|기억|380,000|정하나|
|**108**|**여행**|**150,000**|**NULL**|

```SQL
-- EX) 부서번호가 10번인 각 직원의 이름과 사번, 부서본호, 부서이름 출력
SELECT EMPNO, ENAME, DEPTNO,
        (SELECT DNAME
         FROM DEPT D
         WHERE D.DEPTNO = E.DEPTNO) AS DNAME
FROM EMP E
WHERE DEPTNO 10;
```

```SQL
-- EX) 사원, 직원이름, 부서번호, 급여, 총 급여 출력
SELECT EMPNO, ENAME, DEPTNO, SAL,
        (SELECT SUM(SAL)
         FROM EMP) AS TOTAL_SAL
FROM EMP;
```

- 원래 SUM 함수는 집계함수로 각 행들의 값을 하나의 값으로 요약하는 함수이기에 다른 컬럼과 함께 SELECT 절에 올수 없다. 하지만 서브쿼리를 통해 단일값으로 가져와 각 직원정보의 행마다 4번째 컬럼값으로 넣어줄 수 있다.

#### ② 인라인 뷰 (Inline View) = 동적 뷰(Dynamic View)
- FROM절에 사용하는 서브쿼리
    - **중첩 서브쿼리와 다르게 서브쿼리의 결과를 메인 쿼리의 어느 절에서도 사용 가능**
- **서브쿼리의 결과를 테이블처럼 사용**하기 위해 사용
- 뷰(View)처럼, 쿼리 내에서 임시적으로 생성된 결과를 테이블처럼 사용할 수 있다.
    - 쿼리를 실행할 때만 존재하며 데이터베이스에 저장되지 않는다. => 일회성
- 다른 테이블과 조인 시 반드시 **테이블 별칭을 명시**해야 함

```SQL
SELECT * | 컬럼명 | 표현식,
FROM (SELECT * | 컬럼명 | 표현식
      FROM 테이블명/뷰명)
WHERE 조건;
```

```SQL
-- EX) 각 작가의 평균 수입보다 높은 가격인 그림들의 목록
SELECT p.artist_id, p.name, p.price, p2.avg_price
FROM PAINTINGS p,
    (SELECT artist_id, AVG(price) AS avg_prive
     FROM PAINTINGS
     GROUP BY artist_id) p2
WHERE p.artist_id = p2.artist_id
AND p.price > p2.avg_price;
```

#### 💡 인라인 뷰의 실행 원리/순서
① 서브쿼리(인라인뷰)
- 서브쿼리가 각 작가별 평균 작품의 가격을 계산
- 계산된 결과는 다중행, 다중컬럼을 가진 일종의 테이블
- **WHERE절에서 조인을 해야하므로 서브쿼리의 결과는 무조건 별칭을 가져야 함**

② FROM
- PAINTINGS 테이블 p와 서브쿼리로부터 받은 임시테이블 p2를 조인
- 두 테이블 사이에 명확한 JOIN 조건이 존재하지 않아 Caresian Product 생성

③ WHERE
- p.artist_id = p2.artist_id인 데이터 찾기
- p.price > p2.avg_price를 만족하는 행을 필터링

④ SELECT
- 최종적으로 SELECT절에서 선택한 행들만 반환

|artist_id|name|price|avg_price|
|---|---|---|---|
|1|밤의 도시|1,350,000|1,225,000|
|5|밤 비|920,000|650,000|

#### 💡 조인을 명시해주었다면
- 조인의 종류를 명시하면 불필요한 조합이 생성되지 않는다.
```SQL
SELECT p.artist_id, p.name, p.price, p2.avg_price
FROM paintings p
INNER JOIN (
    SELECT artist_id, AVG(price) AS avg_price
    FROM paintings
    GROUP BY artist_id) p2
ON p.artist_id = p2.artist_id
WHERE p.price > p2.avg_price;
```

```SQL
-- EX) 2020년에 입사한 사원들의 정보와 각 사원들의 부양가족 수 조회
SELECT E.사원번호, E.사원면, D.부서번호, D.부서명,
    (SELECT COUNT(*)
     FROM 부양가족 F
     WHERE F.사원번호 = E.사원번호) AS 부양가족수
FROM 부서 D, (SELECT *
             FROM 사원
             WHERE 입사년도 = '2020') E
WHERE D.부서번호 = E.부서번호
```

#### 💡 스칼라 서브쿼리와의 차이
- 스칼라 서브쿼리는 단일 값을 반환해야 하므로 하나의 컬럼만 선택할 수 있으며, 메인쿼리의 각 행마다 독립적으로 실행된다.
- 인라인 뷰는 테이블 형태의 결과를 반환해야 하므로 메인쿼리에서 필요한 컬럼들이 서브쿼리 안에 포함되어야 한다.
- 메인쿼리에서 조인할 때, 서브쿼리로부터 얻은 임시 테이블의 컬럼이 필요하니 반드시 해당 쿼리는 인라인 뷰안에 명시되어야 한다.
- 인라인 뷰에서 집계함수를 사용하고 해당 결과 값을 메인쿼리의 조건절인 WHERE절에 사용해야 한다면 별칭을 무조건 정해주어야 한다.
    - WHERE 절에는 집계함수를 사용할 수 없으니까

#### ③ 중첩 서브쿼리 (Nested Subquery)
- WHERE절이나 HAVING절과 같은 조건절에서 쓰이는 서브쿼리
- **메인쿼리의 데이터를 필터링하거나 비교할 때 사용**
- 반환 데이터의 형태가 여러 가지(단일, 다중, 다중컬럼, 연관/비연관)

```SQL
SELECT * | 컬럼명 | 표현식,
FROM 테이블명/뷰명
WHERE 조건연산자 (SELECT * | 컬럼명 | 표현식
                 FROM 테이블명/뷰명
                 WHERE 조건);
```

① 반환종류 : 단일행 서브쿼리
- 서브쿼리 결과로 1개의 행이 반환
- 단일행 비교연산자: =, <>, >, >=, <, <=

```SQL
-- EX) 평균 본급보다 높은 봉급을 가진 직원의 사번, 이름, 봉급 출력
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL > (SELECT AVG(SAL)
             FROM EMP);
```

```SQL
-- EX) 강감찬 소속 팀에 소속된 팀의 선수들 정보 출력
SELECT PLAYER_NAME, POSITION, BACK_NO
FROM PLAYER
WHERE TEAM_ID = (SELECT TEAM_ID
                 FROM PLAYER
                 WHERE PLAYER_NAME = '강감찬')
```

② 반환종류: 다중행 서브쿼리
- 서브쿼리의 결과로 여러 행이 반환

|다중행 비교 연산자|설명|
|---|---|
|IN|결과에 값이 포함되는지 확인|
|ANY|결과 중 하나라도 조건을 만족하는지|
|ALL|모든 값이 조건을 만족하는지|
|EXISTS|결과가 존재하는지 여부를 확인|

|연산자|설명|비교|
|---|---|---|
|> ANY|최소값 반환|> ANY(10,200) : 최소값(10)보다 큰 행들 반환|
|< ANY|최대값 반환|< ANY(10,200) : 최대값(200)보다 작은 행들 반환|
|> ALL|최대값 반환|> ANN(10,200) : 최대값(200)보다 큰 행들 반환|
|< ALL|최소값 반환|< ALL(10,200) : 최소값(10)보다 작은 행들 반환|

```SQL
-- EX) 10번 부서의 사원들의 봉급 중 최소 봉급보다 많이 받는 사원 정보 조회
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL > ANY(SELECT SAL
                FROM EMP
                WHERE DEPTNO = 10);
```

③ 반환종류 : 다중컬럼 서브쿼리 (SQL Server 지원X)
- 서브쿼리의 결과로 여러 개의 컬럼이 반환
- 메인쿼리의 비교 컬럼이 2개 이상인 경우
- 대소 비교 전달 불가(두 값을 동시에 묶어서 대소비교할 수 없으니)

```SQL
-- EX) 부서별 최대 급여자들의 정보 출력
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
                        FROM EMP
                        GROUP BY DEPTNO);
```

```SQL
-- EX) 소속팀별 키가 가장 작은 사람들의 정보 출력
SELECT TEAM_ID, PLAYER_NAME, HEIGHT
FROM PLAYER
WHERE (TEAM_ID, HEIGHT) IN (SELECT TEAM_ID, MIN(HEIGHT)
                            FROM PLAYER
                            GROUP BY TEAM_ID);
```

④ 반환종류 : 상호연관 서브쿼리
- 메인쿼리와 서브쿼리의 비교 수행
- 서브쿼리 내에 메인쿼리의 컬럼이 사용됨
- 비교할 집단이나 조건은 서브쿼리에 명시
    - 메인쿼리절엔 서브쿼리 컬럼이 정의되어 있지 않으니 오류 발생

#### EX) 부서별 해당 부서의 평균급여보다 높은 급여를 받는 사원 정보
```SQL
-- 오류 쿼리 : 다중 컬럼 서브쿼리는 두 컬럼에 대해 동시 대소비교 불가능
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) > (SELECT DEPTNO, AVG(SAL)
                        FROM EMP
                        GROUP BY DEPTNO);

-- 정상 : 대소비교할 컬럼을 메인쿼리에 두고, 일치조건은 서브쿼리에 전달
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP E1
WHERE SAL > (SELECT AVG(SAL)
             FROM EMP E2
             WHERE E1.DEPTNO = E2.DEPTNO
             GROUP BY DEPTNO);
```
- 메인쿼리와 결과적으로 비교해야 할 컬럼은 SAL, DEPTNO인데, 그 중 SAL에 대한 대소비교 전에 먼저 비교할 DEPTNO가 확정되어야 함
- 먼저 비교할 DEPTNO값을 서브쿼리에 전달
- 메인쿼리에는 서브쿼리의 테이블 정보가 없으므로 메인쿼리에 E.DEPTNO = D.DEPTNO조건은 사용불가

#### 💡 상호연관 서브쿼리의 연산 순서
① 메인쿼리의 테이블 READ

② 메인쿼리의 WHERE절 확인

③ 서브쿼리 테이블 READ

④ 서브쿼리 WHERE 절 확인

⑤ E1.DEPTNO와 서브쿼리의 DEPTNO와 비교

⑥ 위 조건에 성립하는 행들의 그룹연산 결과 확인(AVG(SAL))

⑦ 해당 결과를 메인쿼리에 전달해 해당 조건을 만족하는 행만 추출

#### 💡 상호연관 서브쿼리 사용 시 GROUP BY 생략 가능
```SQL
SELECT a.name AS artist_name
FROM artists a
WHERE a.id = (
    -- 비상관 서브쿼리 : 메인쿼리의 컬럼을 갖지 X
    SELECT p.artist_id
    FROM paintings p
    WHERE p.price = (SELECT MAX(price) FROM paintings)
);


SELECT p.id, p.name, p.price, a.name AS artist_name
FROM paintings p
JOIN artists a ON p.artist_id = a.id
WHERE p.price > (
    -- 상관 서브쿼리 : 메인쿼리의 컬럼을 갖음
    SELECT AVG(p2.price)
    FROM paintings p2
    WHERE p2.artist_id = p.artist_id
);
```



<br />

📖 Reference
- [2024 개념정리](https://bruders.tistory.com/)

