## ⭐ 서브쿼리
- 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문

```SQL
SELECT p.id
      ,p.name
      ,p.price
      ,( SELECT a.name
         FROM artists a
         WHERE a.id = p.artist_id ) AS artist_name
FROM paintings p;
```

### 서브쿼리 사용 시 주의사항
- 괄호로 감싸서 사용
- 단일행 또는 복수행 비교 연산자와 함께 사용 가능
    - 단일행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하여야 하며, 복수행 비교 연산자는 서브쿼리의 결과 건수와 상관없음
- 서브쿼리엔 ORDER BY 사용 불가 **(ORDER BY 절에서 사용 가능)**
    - ORDER BY절은 SELECT절에서 오직 한 개만 올 수 있음
    - ORDER BY는 메인쿼리의 마지막 문장에 위치해야 함
    - 예외: TOP-N분석
- 서브쿼리는 쿼리 안에 포함된 또 다른 쿼리로, 메인쿼리를 보조하는 하위 쿼리
- 다양한 위치에서 사용될 수 있다.
    - SELECT절에서 특정 값을 계산하여 반환
    - FROM절에서 마치 테이블처럼 사용되어 서브쿼리의 결과를 임시 테이블로 취급
    - WHERE절에서 조건을 지정하는데 사용

### 서브쿼리가 위치할 수 있는 곳
- SELECT, FROM, WHERE, HAVING, ORDER BY 절 **[GROUP BY 불가]**
- 기타 DML: INSERT문의 VALUES절, UPDATE문의 SET절

### 동작 방식에 따른 서브쿼리 분류
- 연관 서브쿼리 (Correlated Subquery)
    - 서브쿼리가 메인쿼리의 컬럼을 가짐
- 비연과 서브쿼리(Un-Correlated Subquery)
    - 서브쿼리가 메인쿼리의 컬럼을 가지지 않음

#### ⭐ 목적
- 연관 서브쿼리
    - 일반적으로 메인쿼리가 먼저 수행되어 읽은 데이터를 서브쿼리에서 조건이 맞는지 확인할 때 사용
- 비연관 서브쿼리
    - 메인쿼리에 서브쿼리가 실행된 결과값을 제공하기 위한 목적으로 주로 사용
- 즉, 메인쿼리의 결과가 서브쿼리로 제공될 수 있고, 서브쿼리의 결과가 메인쿼리로 제공될 수 있음
    - 실행 순서는 상황에 따라 다르다는 것

### 반환되는 데이터 형태에 따른 서브쿼리 분류
- 단일행 서브쿼리
    - 서브쿼리의 실행 결과가 항상 1건 이하
    - 단일행 비교 연산자와 함께 사용 (=, <, <=, >, >=, <>)
    - 다중행 비교 연산자고 사용 가능
- 다중행 서브쿼리
    - 서브쿼리의 실행 결과가 여러 건인 서브쿼리
    - 다중행 비교 연산자와 함께 사용(IN, ALL, ANY, SOME, EXISTS)
    - 단일행 비교 연산자 사용 불가능
- 다중컬럼 서브쿼리
    - 서브쿼리의 실행 결과로 여러 컬럼 반환
    - 주로 메인쿼리의 조건과 비교하기 위해 사용
        - 비교하고자 하는 컬럼의 개수와 위치가 동일해야 함

### 위치에 따른 서브쿼리 분류
#### ① 스칼라 서브쿼리 (Scalar Subquery)
- SELECT절에 사용하는 서브쿼리
- 서브쿼리가 단일행, 단일열을 반환
- **서브쿼리의 결과를 하나의 열처럼 사용**하기 위해 사용

```SQL
SELECT * | 컬럼명 | 표현식,
    (SELECT * | 컬럼명 | 표현식
     FROM 테이블명/뷰명
     WHERE 조건)
FROM 테이블명/뷰명;
```

#### paintins 테이블
|id|name|artist_id|price|
|---|---|---|---|
|101|숲과 나|1|1,100,000|
|102|반의 도시|1|1,350,000|
|103|파도|2|470,000|
|104|Pop!|3|750,000|
|105|너|4|640,000|
|106|밤 비|5|920,000|
|107|기억|5|380,000|

#### artists 테이블
|id|name|
|---|---|
|1|이지현|
|2|황현석|
|3|박성진|
|4|백예서|
|5|정하나|

```SQL
SELECT p.id, p.name, p.price,
        (SELECT a.name
         FROM artists a
         WHERE a.id = p.artist_id) AS artist_name
FROM paintings p;
```

|id|name|price|artist_name|
|---|---|---|---|
|101|숲과 나|1,100,000|이지현|
|102|반의 도시|1,350,000|이지현|
|103|파도|470,000|황현석|
|104|Pop!|750,000|박성진|
|105|너|640,000|백예서|
|106|밤 비|920,000|정하나|
|107|기억|380,000|정하나|

- 각 작품의 번호, 이름, 가격과 그 작품에 대한 작가 정보를 가져오기
- **메인 쿼리의 각 행에 대해 하나의 단일값(예술가 이름)을 반환**
- 스칼라 서브쿼리는 OUTER JOIN연산을 사용한 결과와 같다.


```SQL
-- 같은 결 과 반환
SELECT p.id, p.name, p.price, a.name
FROM paintings p
LEFT JOIN artists a
ON p.artist_id = a.id
```

⭐ **매칭되는 데이터가 없는 경우 해당 컴럼에 대한 값은 NULL로 표현(생략되는 것이 아님)**

|id|name|price|artist_name|
|---|---|---|---|
|101|숲과 나|1,100,000|이지현|
|102|반의 도시|1,350,000|이지현|
|103|파도|470,000|황현석|
|104|Pop!|750,000|박성진|
|105|너|640,000|백예서|
|106|밤 비|920,000|정하나|
|107|기억|380,000|정하나|
|**108**|**여행**|**150,000**|**NULL**|

```SQL
-- EX) 부서번호가 10번인 각 직원의 이름과 사번, 부서본호, 부서이름 출력
SELECT EMPNO, ENAME, DEPTNO,
        (SELECT DNAME
         FROM DEPT D
         WHERE D.DEPTNO = E.DEPTNO) AS DNAME
FROM EMP E
WHERE DEPTNO 10;
```

```SQL
-- EX) 사원, 직원이름, 부서번호, 급여, 총 급여 출력
SELECT EMPNO, ENAME, DEPTNO, SAL,
        (SELECT SUM(SAL)
         FROM EMP) AS TOTAL_SAL
FROM EMP;
```

- 원래 SUM 함수는 집계함수로 각 행들의 값을 하나의 값으로 요약하는 함수이기에 다른 컬럼과 함께 SELECT 절에 올수 없다. 하지만 서브쿼리를 통해 단일값으로 가져와 각 직원정보의 행마다 4번째 컬럼값으로 넣어줄 수 있다.

#### ② 인라인 뷰 (Inline View) = 동적 뷰(Dynamic View)
- FROM절에 사용하는 서브쿼리
    - **중첩 서브쿼리와 다르게 서브쿼리의 결과를 메인 쿼리의 어느 절에서도 사용 가능**
- **서브쿼리의 결과를 테이블처럼 사용**하기 위해 사용
- 뷰(View)처럼, 쿼리 내에서 임시적으로 생성된 결과를 테이블처럼 사용할 수 있다.
    - 쿼리를 실행할 때만 존재하며 데이터베이스에 저장되지 않는다. => 일회성
- 다른 테이블과 조인 시 반드시 **테이블 별칭을 명시**해야 함

```SQL
SELECT * | 컬럼명 | 표현식,
FROM (SELECT * | 컬럼명 | 표현식
      FROM 테이블명/뷰명)
WHERE 조건;
```

```SQL
-- EX) 각 작가의 평균 수입보다 높은 가격인 그림들의 목록
SELECT p.artist_id, p.name, p.price, p2.avg_price
FROM PAINTINGS p,
    (SELECT artist_id, AVG(price) AS avg_prive
     FROM PAINTINGS
     GROUP BY artist_id) p2
WHERE p.artist_id = p2.artist_id
AND p.price > p2.avg_price;
```

#### 💡 인라인 뷰의 실행 원리/순서
① 서브쿼리(인라인뷰)
- 서브쿼리가 각 작가별 평균 작품의 가격을 계산
- 계산된 결과는 다중행, 다중컬럼을 가진 일종의 테이블
- **WHERE절에서 조인을 해야하므로 서브쿼리의 결과는 무조건 별칭을 가져야 함**

② FROM
- PAINTINGS 테이블 p와 서브쿼리로부터 받은 임시테이블 p2를 조인
- 두 테이블 사이에 명확한 JOIN 조건이 존재하지 않아 Caresian Product 생성

③ WHERE
- p.artist_id = p2.artist_id인 데이터 찾기
- p.price > p2.avg_price를 만족하는 행을 필터링

④ SELECT
- 최종적으로 SELECT절에서 선택한 행들만 반환

|artist_id|name|price|avg_price|
|---|---|---|---|
|1|밤의 도시|1,350,000|1,225,000|
|5|밤 비|920,000|650,000|

#### 💡 조인을 명시해주었다면
- 조인의 종류를 명시하면 불필요한 조합이 생성되지 않는다.
```SQL
SELECT p.artist_id, p.name, p.price, p2.avg_price
FROM paintings p
INNER JOIN (
    SELECT artist_id, AVG(price) AS avg_price
    FROM paintings
    GROUP BY artist_id) p2
ON p.artist_id = p2.artist_id
WHERE p.price > p2.avg_price;
```

```SQL
-- EX) 2020년에 입사한 사원들의 정보와 각 사원들의 부양가족 수 조회
SELECT E.사원번호, E.사원면, D.부서번호, D.부서명,
    (SELECT COUNT(*)
     FROM 부양가족 F
     WHERE F.사원번호 = E.사원번호) AS 부양가족수
FROM 부서 D, (SELECT *
             FROM 사원
             WHERE 입사년도 = '2020') E
WHERE D.부서번호 = E.부서번호
```

#### 💡 스칼라 서브쿼리와의 차이
- 스칼라 서브쿼리는 단일 값을 반환해야 하므로 하나의 컬럼만 선택할 수 있으며, 메인쿼리의 각 행마다 독립적으로 실행된다.
- 인라인 뷰는 테이블 형태의 결과를 반환해야 하므로 메인쿼리에서 필요한 컬럼들이 서브쿼리 안에 포함되어야 한다.
- 메인쿼리에서 조인할 때, 서브쿼리로부터 얻은 임시 테이블의 컬럼이 필요하니 반드시 해당 쿼리는 인라인 뷰안에 명시되어야 한다.
- 인라인 뷰에서 집계함수를 사용하고 해당 결과 값을 메인쿼리의 조건절인 WHERE절에 사용해야 한다면 별칭을 무조건 정해주어야 한다.
    - WHERE 절에는 집계함수를 사용할 수 없으니까

#### ③ 중첩 서브쿼리 (Nested Subquery)
- WHERE절이나 HAVING절과 같은 조건절에서 쓰이는 서브쿼리
- **메인쿼리의 데이터를 필터링하거나 비교할 때 사용**
- 반환 데이터의 형태가 여러 가지(단일, 다중, 다중컬럼, 연관/비연관)

```SQL
SELECT * | 컬럼명 | 표현식,
FROM 테이블명/뷰명
WHERE 조건연산자 (SELECT * | 컬럼명 | 표현식
                 FROM 테이블명/뷰명
                 WHERE 조건);
```

① 반환종류 : 단일행 서브쿼리
- 서브쿼리 결과로 1개의 행이 반환
- 단일행 비교연산자: =, <>, >, >=, <, <=

```SQL
-- EX) 평균 본급보다 높은 봉급을 가진 직원의 사번, 이름, 봉급 출력
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL > (SELECT AVG(SAL)
             FROM EMP);
```

```SQL
-- EX) 강감찬 소속 팀에 소속된 팀의 선수들 정보 출력
SELECT PLAYER_NAME, POSITION, BACK_NO
FROM PLAYER
WHERE TEAM_ID = (SELECT TEAM_ID
                 FROM PLAYER
                 WHERE PLAYER_NAME = '강감찬')
```

② 반환종류: 다중행 서브쿼리
- 서브쿼리의 결과로 여러 행이 반환

|다중행 비교 연산자|설명|
|---|---|
|IN|결과에 값이 포함되는지 확인|
|ANY|결과 중 하나라도 조건을 만족하는지|
|ALL|모든 값이 조건을 만족하는지|
|EXISTS|결과가 존재하는지 여부를 확인|

|연산자|설명|비교|
|---|---|---|
|> ANY|최소값 반환|> ANY(10,200) : 최소값(10)보다 큰 행들 반환|
|< ANY|최대값 반환|< ANY(10,200) : 최대값(200)보다 작은 행들 반환|
|> ALL|최대값 반환|> ANN(10,200) : 최대값(200)보다 큰 행들 반환|
|< ALL|최소값 반환|< ALL(10,200) : 최소값(10)보다 작은 행들 반환|

```SQL
-- EX) 10번 부서의 사원들의 봉급 중 최소 봉급보다 많이 받는 사원 정보 조회
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL > ANY(SELECT SAL
                FROM EMP
                WHERE DEPTNO = 10);
```

③ 반환종류 : 다중컬럼 서브쿼리 (SQL Server 지원X)
- 서브쿼리의 결과로 여러 개의 컬럼이 반환
- 메인쿼리의 비교 컬럼이 2개 이상인 경우
- 대소 비교 전달 불가(두 값을 동시에 묶어서 대소비교할 수 없으니)

```SQL
-- EX) 부서별 최대 급여자들의 정보 출력
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
                        FROM EMP
                        GROUP BY DEPTNO);
```

```SQL
-- EX) 소속팀별 키가 가장 작은 사람들의 정보 출력
SELECT TEAM_ID, PLAYER_NAME, HEIGHT
FROM PLAYER
WHERE (TEAM_ID, HEIGHT) IN (SELECT TEAM_ID, MIN(HEIGHT)
                            FROM PLAYER
                            GROUP BY TEAM_ID);
```

④ 반환종류 : 상호연관 서브쿼리
- 메인쿼리와 서브쿼리의 비교 수행
- 서브쿼리 내에 메인쿼리의 컬럼이 사용됨
- 비교할 집단이나 조건은 서브쿼리에 명시
    - 메인쿼리절엔 서브쿼리 컬럼이 정의되어 있지 않으니 오류 발생

#### EX) 부서별 해당 부서의 평균급여보다 높은 급여를 받는 사원 정보
```SQL
-- 오류 쿼리 : 다중 컬럼 서브쿼리는 두 컬럼에 대해 동시 대소비교 불가능
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) > (SELECT DEPTNO, AVG(SAL)
                        FROM EMP
                        GROUP BY DEPTNO);

-- 정상 : 대소비교할 컬럼을 메인쿼리에 두고, 일치조건은 서브쿼리에 전달
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP E1
WHERE SAL > (SELECT AVG(SAL)
             FROM EMP E2
             WHERE E1.DEPTNO = E2.DEPTNO
             GROUP BY DEPTNO);
```
- 메인쿼리와 결과적으로 비교해야 할 컬럼은 SAL, DEPTNO인데, 그 중 SAL에 대한 대소비교 전에 먼저 비교할 DEPTNO가 확정되어야 함
- 먼저 비교할 DEPTNO값을 서브쿼리에 전달
- 메인쿼리에는 서브쿼리의 테이블 정보가 없으므로 메인쿼리에 E.DEPTNO = D.DEPTNO조건은 사용불가

#### 💡 상호연관 서브쿼리의 연산 순서
① 메인쿼리의 테이블 READ

② 메인쿼리의 WHERE절 확인

③ 서브쿼리 테이블 READ

④ 서브쿼리 WHERE 절 확인

⑤ E1.DEPTNO와 서브쿼리의 DEPTNO와 비교

⑥ 위 조건에 성립하는 행들의 그룹연산 결과 확인(AVG(SAL))

⑦ 해당 결과를 메인쿼리에 전달해 해당 조건을 만족하는 행만 추출

#### 💡 상호연관 서브쿼리 사용 시 GROUP BY 생략 가능
```SQL
SELECT a.name AS artist_name
FROM artists a
WHERE a.id = (
    -- 비상관 서브쿼리 : 메인쿼리의 컬럼을 갖지 X
    SELECT p.artist_id
    FROM paintings p
    WHERE p.price = (SELECT MAX(price) FROM paintings)
);


SELECT p.id, p.name, p.price, a.name AS artist_name
FROM paintings p
JOIN artists a ON p.artist_id = a.id
WHERE p.price > (
    -- 상관 서브쿼리 : 메인쿼리의 컬럼을 갖음
    SELECT AVG(p2.price)
    FROM paintings p2
    WHERE p2.artist_id = p.artist_id
);
```

### 서브쿼리 사용시 주의사항2
- 조인할 테이블의 기본키가 2개 이상이라면 WHERE절에서 조인(=)에 사용되는 기본키에도 두 키를 모두 사용해줘야 한다.

```SQL
-- 주문 항목을 저장하는 테이블
CREATE TABLE order_items(
    order_id INT,
    product_id INT,
    quantity INT,
    price DECIMAL(10, 2),
    PRIMARY KEY (order_id, product_id)
);

SELECT a.order_id, a.product_id,
       a.quantity, a.price,
       (SELECT SUM(b.quantity * b.price)
        FROM order_items b
        WHERE b.order_id = a.order_id
        AND b.product_id = a.product_id) AS total_amount
FROM order_items a;
```

### HAVING절에서 서브쿼리
- 그룹함수와 함께 사용될 때, 그룹필된 결과에 대해 부가 조건을 걸기 위해 사용

### UPDATE문의 SET절에서 서브쿼리
- **서브쿼리를 사용한 변경 작업을 할때, 서브쿼리 결과가 NULL을 반환하면 해당 컬럼 결과가 NULL이 될 수 있기 때문에 주의**

### NOT EXISTS와 서브쿼리
- WHERE문에 NOT EXISTS는 서브쿼리 테이블의 결과물을 제외한 나머지를 메인쿼리에 출력
- 메인쿼리에서 서브쿼리의 결과물이랑 겹치는 애들은 제외(차집합)

### EXISTS와 서브쿼리
- WHERE문에 EXISTS는 서브쿼리 테이블의 결과물과 겹치는 데이터만 메인쿼리에 출력

## 집합 연산자
### 집합 연산자
- SELECT문 결과를 하나의 집합으로 간주
    - 그 집합에 대한 합집합, 교집합, 차집합의 연산
- **두 집합의 각 컬럼의 순서와 데이터 타입이 상호 호환 가능해야 함**
- **전체 집합의 컬럼명과 데이터 타입은 첫 번째 집합에 의해 결정됨**
- 두 집합 사이에 집합 연산자 정의
- 두 개 이상의 테이블에서 JOIN을 사용하지 않고, 연관된 데이터를 조회하는 방법

### 합집합 (UNION, UNION ALL)
- 두 집합의 합집합

① UNION
- **중복된 데이터는 한 번만 출력**
- 중복된 데이터를 제거하기 위해 내부적으로 정렬 수행
    - 따라서 추가적인 연산을 하지 않게 하기 위해, 중복된 데이터가 없을 경우 UNION ALL을 사용하는게 좋음

```SQL
-- 스윗홈 시즌 1,2 출연 배우 모두 조회(중복은 한 번만)
SELECT 배역명, 본명 FROM sweethome1
UNION
SELECT 배역명, 본명 FROM sweethome2;
```

② UNION ALL
- **중복된 데이터를 제거하지 않고 모든 행 반환**

```SQL
-- 스윗홈 시즌 1,2 출연 배우 모두 조회(중복 괜찮음)
SELECT 배역명, 본명 FROM sweethome1
UNION
SELECT 배역명, 본명 FROM sweethome2;
```

### 교집합 (INTERSECT - 중복제거)
- 두 집합의 공통으로 있는 행 출력
```SQL
-- 스윗홈 시즌1,2에 모두 출연한 배우 조회
SELECT 배역명, 본명 FROM sweethome1
INTERSECT
SELECT 배역명, 본명 FROM sweethome2;
```

### 차집합 (ORACLE: MINUS) EXCEPT
- 두 집합 중 한 쪽 집합에만 존재하는 행 출력
- **(A-B)와 (B-A)는 다르니 집합의 순서에 주의**
```SQL
-- 시즌 1에는 출연했으나 시즌 2에는 출연하지 않은 배우 조회
SELECT 배역명, 본명 FROM sweethome1
MINUS
SELECT 배역명, 본명 FROM sweethome2;

-- 시즌 2에는 출연했으나 시즌 1에는 출연하지 않은 배우 조회
SELECT 배역명, 본명 FROM sweethome2
MINUS
SELECT 배역명, 본명 FROM sweethome1;
```

### 집합 연산자 사용시 주의사항
① 두 집합의 컬럼 수가 일치해야 함

② 두 집합의 컬럼 순서 일치해야 함 (오류가 발생하지는 않음)

③ 두 집합의 각 컬럼의 데이터 타입이 상호 호환 가능해야 함

④ 각 컬럼의 사이즈는 달라도 됨

⑤ **개별 SELECT문에 ORDER BY 불가(GROUP BY는 가능)**
- 아래 집합의 ORDER BY는 집합 연산자 전체 결과에 대한 ORDER BY로 적용됨
    - 1:1의 테이블 관계
        - EXCEPT 결과는 항상 공집합
        - INTERSECT와 JOIN 연산의 결과는 같다.
        - INTERSECT와 UNION의 결과는 같다.
        - UNION ALL 수행 시 결과는 한 테이블의 전체 건수에 2배가 된다. (UNION 수행 시 결과 건수는 같음)
    - 1:N의 테이블 관계
        - INTERSECT보다 JOIN의 연산 결과 수가 더 많다.

## 그룹 함수
### ANSI/ISO SQL 표준 데이터 분석을 위한 세 가지의 함수
- AGGREGATE FUNCTION 집계 함수
- GROUP FUNCTION 그룹 함수
- WINDOW FUNCTION 윈도우 함수

### AGGREGATE 집계함수 (⭐NULL값 무시)
① COUNT
- 행의 수를 세는 함수
- 모든 데이터 타입에 사용가능
- 대상 컬럼은 * 또는 단 하나의 컬럼
    - ⭐해당 컬럼의 값이 NULL인 경우 COUNT 제외
- PK 컬럼의 경우 NULL일 수 없으니 전체 행의 수를 세고 싶을 때는 PK컬럼이나 NOT NULL 컬럼을 사용하는 것이 좋음

② SUM
- 총 합 출력
- 숫자 컬럼에만 사용가능

③ AVG
- 평균 출력
- 숫자 컬럼에만 사용가능
- **NULL을 제외한 대상의 평균을 반환하니 전체 대상 평균 연산 시 주의**

```SQL
AVG(SAL)
SUM(SAL) / COUNT(EMPNO) -- empno : PK
AVG(NVL(SAL,0))
```
- 전체 10명,  그 중 NULL 값을 5명이 가졌다면 AVG()는 5명에 대한 평균을 계산하게 된다.
- 전체 평균을 구하고 싶으면 SUM() / COUNT(NOT NULL 컬럼)이나 NVL(SAL, 0)로 NULL값을 0으로 바꾼 후 구하면 된다.

④ MIN / MAX
- 최소 / 최대 출력
- 날짜, 숫자, 문자 컬럼에 모두 사용 가능

⑤ VARIANCE / STDDEV
- 분산과 표준편차 (분산의 루트값)

### ⭐ GROUP FUNCTION 그룹함수
```SQL
-- 부서별 업무별 사원수와 급여 합 조회
SELECT DNAME, JOB,
        COUNT(*) "Total Empl",
        SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME, JOB;
```
- 별도의 그룹함수를 GROUP BY 절에 적지 않을 경우 소계나 총 합계가 따로 생성되지 않는다.
- GROUP BY절 사용시 자동 정렬이 수행되지 않으니, 정렬이 필요한 경우엔 ORDER BY절에 명시적으로 정렬 컬럼을 표시해야 한다.

① ROLLUP 함수
```SQL
SELECT DNAME, JOB,
        COUNT(*) "Total Empl"
        SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB)
ORDER BY DNAME, JOB;
```
|DNAME|JOB|Total Empl|Total Sal|
|---|---|---|---|
|ACCOUNTING|CLERK|1|1300|
|ACCOUNTING|MANAGER|1|2450|
|ACCOUNTING|PRESIDENT|1|5000|
|ACCOUNTING||3|8750|
|RESEARCH|ANALYST|2|6000|
|RESEARCH|CLERK|2|1900|
|RESEARCH|MANAGER|1|2975|
|RESEARCH||5|10875|
|SALES|CLERK|1|950|
|SALES|MANAGER|1|2850|
|SALES|SALESMAN|4|5600|
|SALES||6|9400|
|||14|29025|


- 그룹핑하는 컬럼의 수가 N일 시 N + 1 Level의 Subtotal(소계)가 생성된다.
- **ROLLUP의 인수는 계층 구조라 인수 순서가 바뀌면 수행 결과도 바뀐다.**
- GROUPING COLUMNS인 DNAME과 JOB에 대한 다음과 같은 추가 LEVEL의 집계가 생성되었다.
    - L1 : GROUP BY 수행 시 생성되는 표준 집계 (9건)
    - L2 : DNAME 별 모든 JOB의 SUBTOTAL (3건)
    - L3 : GRAND TOTAL (마지막 행, 1건)
- UNION ALL로 대체 가능
```SQL
-- DNAME과 JOB별 그룹 연산
SELECT DNAME, JOB,
        COUNT(*) AS "Total Empl",
        SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME, JOB
UNION ALL
-- DNAME별 그룹 연산(소계)
SELECT DNAME, NULL AS JOB,
        COUNT(*) AS "Total Empl",
        SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME
UNION ALL
-- 전체 총계
SELECT NULL AS DNAME, NULL AS JOB,
        COUNT(*) AS "Total Empl",
        SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
ORDER BY DNAME, JOB;
```

#### 💡 ROLLUP 인수의 순서를 바꾼다면
```SQL
SELECT NVL(species, '합계') AS species,
        NVL(breed, '합계') AS breed,
        ROUND(AVG(age), 2) AS 평균_나이
FROM ANIMAL_HOTAL
GROUP BY ROLLUP(specied, breed);
```
|specied|breed|평균_나이|
|---|---|---|
|강아지|말티즈|6|
|강아지|비숑 프리제|5|
|강아지|시바견|1|
|강아지|치와와|2|
|강아지|포메라니안|3|
|강아지|푸들|6.5|
|강아지|합계|4.56|
|고양이|러시안블루|2|
|고양이|샴|3.33|
|고양이|스코티쉬 폴드|5|
|고양이|아비시니안|2|
|고양이|페르시안|5.67|
|고양이|합계|4|
|토끼|네덜란드 드워프|2|
|토끼|라이언헤드|3|
|토끼|미니렉스|2|
|토끼|홀랜드 롭|4|
|토끼|합계|2.67|
|합계|합계|3.88|


```SQL
SELECT NVL(species, '합계') AS species,
        NVL(breed, '합계') AS breed,
        ROUND(AVG(age), 2) AS 평균_나이
FROM ANIMAL_HOTAL
GROUP BY ROLLUP(breed, specied);
```
|specied|breed|평균_나이|
|---|---|---|
|토끼|네덜란드 드워프|2|
|합계|네덜란드 드워프|2|
|토끼|라이언헤드|3|
|합계|라이언헤드|3|
|고양이|러시안블루|2|
|합계|러시안블루|2|
|강아지|말티즈|6|
|합계|말티즈|6|
|토끼|미니렉스|2|
|합계|미니렉스|2|
|강아지|비숑 프리제|5|
|합계|비숑 프리제|5|
|...|...|...|
|합계|합계|3.88|

#### ROLLUP 함수에 결합 컬럼 사용
- ROLLUP 함수 사용시 괄호로 묶은 JOB과 MGR의 경우, **하나의 집합 (JOB + MGR)컬럼으로 간주**하여 괄호 내 각 컬럼별 집계를 구하지 않는다.

```SQL
SELECT DNAME, JOB, MGR, SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP (DNAME, (JOB, MGR));
```
|DNAME|JOB|MGR|Total Sal|
|---|---|---|---|
|SALES|CLERK|7698|950|
|SALES|MANAGER|7839|2850|
|SALES|SALESMAN|7698|5600|
|SALES|||9400|
|RESEARCH|CLERK|7788|1100|
|RESEARCH|CLERK|7902|800|
|RESEARCH|ANALYST|7566|6000|
|RESEARCH|MANAGER|7839|2975|
|RESEARCH|||10875|
|ACCOUNTING|CLERK|7752|1300|
|ACCOUNTING|MANAGER|7839|2450|
|ACCOUNTING|PRESIDENT||5000|
|ACCOUNTING|||8750|
||||29025|

#### ⭐ GROUPING 함수
- 그룹 함수를 지원하기 위한 함수로 ROLLUP이나 CUBE에 의한 소계가 계산된 결과에는 GROUPING(컬럼) = 1이 표시되고, 그 외 결과에는 GROUPING(컬럼) = 0이 표시된다.

```SQL
-- NVL 대신 GROUPING 함수 이용해서 NULL 값 다른 값으로 대체하기
SELECT CASE WHEN GROUPING(DNAME) = 1
            THEN 'All Departments'
            ELSE DNAME END AS DNAME,
       CASE WHEN GROUPING(JOB) = 1
            THEN 'All Jobs'
            ELSE JOB END AS JOB,
       COUNT(*) AS "Total Empl",
       SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB);

-- DECODE를 사용해도 같은 결과
SELECT
DECODE(GROUPING(DNAME), 1, 'All Departments', DNAME) AS DNAME,
DECODE(GROUPING(JOB), 1, 'All Jobs') AS JOB,
COUNT(*) AS "Total Empl",
SUM(SAL) AS "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY ROLLUP(DNAME, JOB);
```

|DNAME|JOB|Total Empl|Total Sal|
|---|---|---|---|
|SALES|CLERK|1|950|
|SALES|MANAGER|1|2850|
|SALES|SALESMAN|4|5600|
|SALES|All Jobs|6|9400|
|RESEARCH|CLERK|2|1900|
|RESEARCH|ANALYST|2|6000|
|RESEARCH|MANAGER|1|2975|
|RESEARCH|All Jobs|5|10875|
|ACCOUNTING|CLERK|1|1300|
|ACCOUNTING|MANAGER|1|2450|
|ACCOUNTING|PRESIDENT|1|5000|
|ACCOUNTING|All Jobs|3|8750|
|All Departments|All Jobs|14|29025|

② CUBE 함수
- 결합 가능한 모든 값에 대하여 다차원 집계 생성
    - **그룹핑되는 컬럼이 가질 수 있는 모든 경우에 대해 소계를 생성**
    - ROLLUP에 비해 시스템에 많은 부담이 생기니 사용에 주의
- ROLLUP과 달리 인수들 간의 간 계층 구조가 아니라 평등한 관계라 **인수의 순서가 바뀌어도 정렬 순서는 바뀔 수 있어도 데이터의 결과는 같다.**
- CUBE(DNAME, JOB)이나 CUBE(JOB, DNAME)이나 같은 결과 도출

```SQL
SELECT DNAME, JOB
    COUNT(*) "Total Empl"
    SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY CUBE(DNAME, JOB);
```

|DNAME|JOB|Total Empl|Total Sal|
|---|---|---|---|
|||14|29025|
||CLERK|4|4150|
||ANALYST|2|6000|
||MANAGER|3|8275|
||SALESMAN|4|5600|
||PRESIDENT|1|5000|
|SALES||6|9400|
|SALES|CLERK|1|950|
|SALES|MANAGER|1|2850|
|SALES|SALESMAN|4|5600|
|RESEARCH||5|10875|
|RESEARCH|CLERK|2|1900|
|RESEARCH|ANALYST|2|6000|
|RESEARCH|MANAGER|1|2975|
|ACCOUNTING||3|8750|
|ACCOUNTING|CLERK|1|1300|
|ACCOUNTING|MANAGER|1|2450|
|ACCOUNTING|PRESIDENT|1|5000|

- GROUP BY ROLLUP(DNAME, JOB)에서는 JOB별 소계는 생성되지 않았지만 CUBE에서는 JOB별 소계도 생성된다.
- 전체 총계도 물론 생성
- ROLLUP과 마찬가지로 UNION ALL을 통해서 표현할 수 있으며, ROLLUP과 달리 JOB컬럼에 대한 소계가 추가되므로 인수가 2개일 경우 총 4개의 SELECT문이 UNION되어야 한다.

③ GROUPING SETS 함수
- CUBE와 마찬가지로 **인수별로 평등한 관계를 가져 컬럼의 나열 순서는 중요하지 않다.**
- ROLLUP과 CUBE와 달리 자동으로 총계가 출력되지 않는다.
    - GROUP BY GROUPING SETS(A,B,())나 GROUP BY GROUPING SETS(A,B, NULL)로 A소계, B소계, 총계 이렇게 총계까지 출력되게 할 수 있다.

```SQL
SELECT DNAME, JOB,
        COUNT(*) "Total Empl",
        SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY GROUPING SETS(DNAME, JOB);
```

|DNAME|JOB|Total Empl|Total Sal|
|---|---|---|---|
||CLERK|4|4150|
||SLAESMAN|4|5600|
||PRESIDENT|1|5000|
||MANAGER|3|8275|
||ANALYST|2|6000|
|ACCOUNTING||3|8750|
|RESEARCH||5|10875|
|SALES||6|9400|

- GROUPING SETS의 경우 인수로 받은 각 컬럼별 소계가 생성된다.
- UNION ALL로 대체 가능

```SQL
-- DNAME별 소계
SELECT DNAME, NULL AS JOB,
        COUNT(*) "Total Empl",
        SUM(SAL) "Total Sal"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY DNAME
UNION ALL
-- JOB별 소계
SELECT NULL AS DNAME, JOB,
        COUNT(*) "Total Empl",
        SUM(SAL) "Total SaL"
FROM EMP, DEPT
WHERE DEPT.DEPTNO = EMP.DEPTNO
GROUP BY JOB;
```

#### ROLLUP / CUBE / GROUPING SETS
<table>
    <thead style="text-align:center">
        <tr>
            <td>표현식</td>
            <td>출력값</td>
            <td>순서 무관</td>
        </tr>
    </thead>
    <tbody style="text-align:center">
        <tr>
            <td>ROLLUP(A, B)</td>
            <td>A와 B별 소계 / A별 소계 / 총계</td>
            <td>X (계층 구조)</td>
        </tr>
        <tr>
            <td>CUBE(A, B)</td>
            <td>A와 B별 소계 / A별 소계 / B별 소계 / 총계</td>
            <td rowspan="2">O (평등 관계)</td>
        </tr>
        <tr>
            <td>GROUPING SETS(A, B)</td>
            <td>A별 소계 / B별 소계</td>
        </tr>
    </tbody>
</table>

- 세 함수 모두 결과 정렬이 필요한 경우 ORDER BY절에 정렬 컬럼을 명시해야 한다.
- CUBE와 ROLLUP함수 모두 GROUPING SETS 함수로 대체 가능하다.

```SQL
-- ROLLUP 이용
SELECT DEPNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

-- GROUPING SETS로
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS((DEPTNO, JOB), DEPTNO, ());
```
```SQL
-- CUBE 이용
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB);

-- GROUPING SETS로
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB, (DEPTNO, JOB), ());
```

## ⭐ WINDOW FUNCTION 윈도우 함수
### 윈도우 함수
- 집계 함수는 보통 그룹별로 집계된 결과를 반환할 때, 원본 데이터의 개별 행 정보는 포함되지 않는다.
    - 각 그룹별 한 행씩 요약해서 출력하는 형태
- 윈도우 함수는 조인과 **서브쿼리를 쓰지 않고도 행과 행 간을 비교, 연산하는 것을 가능하게 해준다.**
- **그룹별 하나의 결과를 반환하는 집계함수와 다르게 데이터의 각 행을 그대로 유지하면서 그룹 내 연산을 수행할 수 있게 해준다.**
- **GROUP BY 없이 그룹 연산을 가능하게 해준다.**

```SQL
SELECT [컬럼],
        윈도우함수([컬럼]) OVER ([PARTITION BY 컬럼]
                              [ORDER BY 컬럼 ASC|DESC]
                              [ROWS|RANGE BETWEEN A AND B]) AS result
FROM 테이블명;
```
- 윈도우 함수: 집계 함수나 순위 함수 등
- PARTITION BY 절: 그룹연산을 수행할 특정 그룹 (= GROUP BY 컬럼)
- ORDER BY 절
    - 순위함수의 경우 필수(정렬컬럼과 순서에 따라 순위가 변하니까)
    - **집계함수는 누적값 출력 시 사용**
- ROWS|RANGE BETWEEN A AND B절 (SQL Server는 지원X)
    - 연산범위 설정
    - **ORDER BY절 필수**
- PARTITION BY, ORDER BY, ROWS|RANGE BETWEEN A AND B 순서 그대로 전달해야 오류X

### 윈도우 함수의 효과
- 서브쿼리나 조인 등으로 해결하던 쿼리를 하나의 SELECT문으로 작성 가능

```SQL
-- 오류: 집계함수결과와 각 컬럼별 행 정보는 동시 출력 불가
SELECT EMPNO, ENAME, SAL, SUM(SAL) AS TOTAL
FROM EMP;

-- 해결방법1. 서브쿼리
SELECT EMPNO, ENAME, SAL,
        (SELECT SUM(SAL) FROM EMP) AS TOTAL
FROM EMP;

-- 해결방법2. 윈도우 함수
SELECT EMPNO, ENAME, SAL,
        SUM(SAL) OVER() AS TOTAL
FROM EMP;
```

### 일반 집계 함수
- SUM, AVG, COUNT, MAX, MIN

```SQL
-- 출판사별 책들의 가격 관련 집계함수 결과
SELECT book_name, writer, publisher, price
        집계함수(price) OVER (PARTITION BY publisher ORDER BY price) AS 컬럼별칭
FROM BOOKSHELF;
```

① 집계함수 = SUM()
- ORDER BY를 명시하지 않을 경우엔 합이 누적으로 계산되지 않음

|book_name|writer|publisher|price|total|
|---|---|---|---|---|
|멋진 신세계|올더스 헉슬리|문학동네|13,000|13,000|
|천개의 찬란한 태양|할레드 호세이니|문학동네|16,000|29,000|
|어린왕자|앙투안 드 생택쥐페리|민음사|8,800|8,800|
|참을 수 없는 존재의 가벼움|밀란 쿤데라|민음사|11,000|19,800|
|데이만|헤르만 헤세|열린책들|12,000|12,000|
|1984|조지 오웰|열린책들|13,500|25,500|
|창문 넘어 도망친 100세 노인|요나스 요나슨|열린책들|15,200|40,700|
|나미야 잡화점의 기적|히가시노 게이고|현대문학|14,800|14,800|

② 집계합수 = AVG()
- ORDER BY를 명시하지 않을 경우엔 평균이 누적으로 계산되지 않음

|book_name|writer|publisher|price|avg|
|---|---|---|---|---|
|멋진 신세계|올더스 헉슬리|문학동네|13,000|13,000|
|천개의 찬란한 태양|할레드 호세이니|문학동네|16,000|14,500|
|어린왕자|앙투안 드 생택쥐페리|민음사|8,800|8,800|
|참을 수 없는 존재의 가벼움|밀란 쿤데라|민음사|11,000|9,900|
|데이만|헤르만 헤세|열린책들|12,000|12,000|
|1984|조지 오웰|열린책들|13,500|12,750|
|창문 넘어 도망친 100세 노인|요나스 요나슨|열린책들|15,200|13,566.57|
|나미야 잡화점의 기적|히가시노 게이고|현대문학|14,800|14,800|

③ 집계함수 = MIN()
- MIN(), MAX()의 경우 ORDER BY 영향X

|book_name|writer|publisher|price|min|
|---|---|---|---|---|
|멋진 신세계|올더스 헉슬리|문학동네|13,000|13,000|
|천개의 찬란한 태양|할레드 호세이니|문학동네|16,000|13,000|
|어린왕자|앙투안 드 생택쥐페리|민음사|8,800|8,800|
|참을 수 없는 존재의 가벼움|밀란 쿤데라|민음사|11,000|8,800|
|데이만|헤르만 헤세|열린책들|12,000|12,000|
|1984|조지 오웰|열린책들|13,500|12,000|
|창문 넘어 도망친 100세 노인|요나스 요나슨|열린책들|15,200|12,000|
|나미야 잡화점의 기적|히가시노 게이고|현대문학|14,800|14,800|

④ 집계함수 = COUNT()
- ORDER BY를 명시하지 않을 경우 개수 합이 누적되지 않음

|book_name|writer|publisher|price|count|
|---|---|---|---|---|
|멋진 신세계|올더스 헉슬리|문학동네|13,000|1|
|천개의 찬란한 태양|할레드 호세이니|문학동네|16,000|2|
|어린왕자|앙투안 드 생택쥐페리|민음사|8,800|1|
|참을 수 없는 존재의 가벼움|밀란 쿤데라|민음사|11,000|2|
|데이만|헤르만 헤세|열린책들|12,000|1|
|1984|조지 오웰|열린책들|13,500|2|
|창문 넘어 도망친 100세 노인|요나스 요나슨|열린책들|15,200|3|
|나미야 잡화점의 기적|히가시노 게이고|현대문학|14,800|1|

### 윈도우 함수의 연산범위 : 집계 연산 시 행의 범위 설정 가능
① ROWS, RANGE
- ROWS : 값이 같더라도 각 행씩 연산
- RANGE : 값이 같으면 하나의 RANGE로 묶어서 동시 연산 (DEFAULT)

② BETWEEN A AND B
- A : 시작점 정의
    - CURRENT ROW : 현재행부터
    - **UNBOUNDED PRECEDING : 처음부터 (DEFAULT)**
    - N PRECEDING : N 이전부터
- B : 마지막 시점 정의
    - **CURRENT ROW : 현재까지 (DEFAULT)**
    - UNBOUNDED FOLLOWING : 마지막까지
    - N FOLLOWING : N 이후까지

|JOB|ENAME|SAL|-|
|---|---|---|---|
|CLERK|SMITH|800|UNBOUNDED PRECEDING : 맨 위의 행|
||...|||
|CLERK|JAMES|950||
|CLERK|ADAMS|1100|PRECEDING : 이전 행|
|CLERK|MILLER|1300|CURRENT ROW : 현재 행|
|MANAGER|CLERK|2450|FOLLOWING : 다음 행|
|MANAGER|BLAKE|2850||
|MANAGER|JONES|2975||
||...|||
|MANAGER|MUELLER|4200|UNBOUNDED FOLLOWING : 맨 아래의 행|

### ROWS와 RANGE의 차이
① RANGE : 값이 같으면 같은 범위로 취급하여 동시 연산

```SQL
SELECT EMPNO, ENAME, SAL
        SUM(SAL) OVER(ORDER BY SAL) AS TOTAL_SAL
FROM EMP;
```
<table>
    <thead style="text-align:center;">
        <tr>
            <td>EMPNO</td>
            <td>ENAME</td>
            <td>SAL</td>
            <td>TOTAL_SAL</td>
        </tr>
    </thead>
    <tbody style="text-align:center;">
        <tr>
            <td>7369</td>
            <td>CLERK</td>
            <td>800</td>
            <td>800</td>
        </tr>
        <tr>
            <td>7900</td>
            <td>JAMES</td>
            <td>950</td>
            <td>1750</td>
        </tr>
        <tr>
            <td>7876</td>
            <td>ADAMS</td>
            <td>1100</td>
            <td>2050</td>
        </tr>
        <tr style="border: 2px solid red;">
            <td>7521</td>
            <td>WARD</td>
            <td>1250</td>
            <td>5350</td>
        </tr>
        <tr style="border: 2px solid red;">
            <td>7654</td>
            <td>MARTIN</td>
            <td>1250</td>
            <td>5350</td>
        </tr>
        <tr>
            <td>7934</td>
            <td>MILLER</td>
            <td>1300</td>
            <td>6650</td>
        </tr>
    </tbody>
</table>

② ROWS : 각 행 별로 연산

```SQL
SELECT EMPNO, ENAME, SAL,
        SUM(SAL) OVER(ORDER BY SAL
                      ROWS BETWEEN UNBOUNDED PRECEDING
                      AND CURRENT ROW) AS TOTAL_SAL
FROM EMP;
```

<table>
    <thead style="text-align:center;">
        <tr>
            <td>EMPNO</td>
            <td>ENAME</td>
            <td>SAL</td>
            <td>TOTAL_SAL</td>
        </tr>
    </thead>
    <tbody style="text-align:center;">
        <tr>
            <td>7369</td>
            <td>CLERK</td>
            <td>800</td>
            <td>800</td>
        </tr>
        <tr>
            <td>7900</td>
            <td>JAMES</td>
            <td>950</td>
            <td>1750</td>
        </tr>
        <tr>
            <td>7876</td>
            <td>ADAMS</td>
            <td>1100</td>
            <td>2050</td>
        </tr>
        <tr style="border: 2px solid red;">
            <td>7521</td>
            <td>WARD</td>
            <td>1250</td>
            <td>4100</td>
        </tr>
        <tr style="border: 2px solid red;">
            <td>7654</td>
            <td>MARTIN</td>
            <td>1250</td>
            <td>5350</td>
        </tr>
        <tr>
            <td>7934</td>
            <td>MILLER</td>
            <td>1300</td>
            <td>6650</td>
        </tr>
    </tbody>
</table>

```SQL
SELECT EMONO, ENAME, SAL,
        SUM(SAL) OVER(ORDER BY SAL
                      ROWS BETWEEN UNBOUNDED PRECEDING
                      AND UNBOUNDED FOLLOWING) AS TOTAL_SAL
FROM EMP;
```

<table>
    <thead style="text-align:center;">
        <tr>
            <td>EMPNO</td>
            <td>ENAME</td>
            <td>SAL</td>
            <td>TOTAL_SAL</td>
        </tr>
    </thead>
    <tbody style="text-align:center;">
        <tr>
            <td>7369</td>
            <td>CLERK</td>
            <td style="border: 2px solid red;">800</td>
            <td>6650</td>
        </tr>
        <tr>
            <td>7900</td>
            <td>JAMES</td>
            <td style="border: 2px solid red;">950</td>
            <td>6650</td>
        </tr>
        <tr>
            <td>7876</td>
            <td>ADAMS</td>
            <td style="border: 2px solid red;">1100</td>
            <td>6650</td>
        </tr>
        <tr>
            <td>7521</td>
            <td>WARD</td>
            <td style="border: 2px solid red;">1250</td>
            <td>6650</td>
        </tr>
        <tr>
            <td>7654</td>
            <td>MARTIN</td>
            <td style="border: 2px solid red;">1250</td>
            <td>6650</td>
        </tr>
        <tr>
            <td>7934</td>
            <td>MILLER</td>
            <td style="border: 2px solid red;">1300</td>
            <td>6650</td>
        </tr>
    </tbody>
</table>

```SQL
SELECT EMONO, ENAME, SAL,
        SUM(SAL) OVER(ORDER BY SAL
                      ROWS BETWEEN UNBOUNDED PRECEDING
                      AND 1 FOLLOWING) AS TOTAL_SAL
FROM EMP;
```
- 현재 연산 중인 행은 첫 행부터 그 다음 행까지 연산
<table>
    <thead style="text-align:center;">
        <tr>
            <td>EMPNO</td>
            <td>ENAME</td>
            <td>SAL</td>
            <td>TOTAL_SAL</td>
        </tr>
    </thead>
    <tbody style="text-align:center;">
        <tr>
            <td>7369</td>
            <td>CLERK</td>
            <td style="border: 2px solid red;">800</td>
            <td>1750</td>
        </tr>
        <tr>
            <td>7900</td>
            <td>JAMES</td>
            <td style="border: 2px solid red;">950</td>
            <td style="border: 2px solid red;">2850</td>
        </tr>
        <tr>
            <td>7876</td>
            <td>ADAMS</td>
            <td style="border: 2px solid red;">1100</td>
            <td>4100</td>
        </tr>
        <tr>
            <td>7521</td>
            <td>WARD</td>
            <td>1250</td>
            <td>5350</td>
        </tr>
        <tr>
            <td>7654</td>
            <td>MARTIN</td>
            <td>1250</td>
            <td>6650</td>
        </tr>
        <tr>
            <td>7934</td>
            <td>MILLER</td>
            <td>1300</td>
            <td>6650</td>
        </tr>
    </tbody>
</table>

### ⭐ 순위 함수
① ROW_NUMBER() : 1위부터 순차적으로 순위부여

② RANK() : 동일한 값에 같은 순위 부여, 그 다음 순위는 건너뜀

③ DENSE_RANK() : 동일한 값에 같은 순위 부여, 그 다음 순위 건너뛰지 않음

```SQL
SELECT 이름, 부서, 급여
        ROW_NUMBER() OVER(PARTITION BY 부서 ORDER BY 급여 DESC) AS row_no,
        RANK() OVER(PARTITION BY 부서 ORDER BY 급여 DESC) AS rank_no,
        DENSE_RANK() OVER(PARTITION BY 부서 ORDER BY 급여 DESC) AS densc_rank_no
FROM EMPLOYEES;
```

<table>
    <thead style="text-align:center">
        <tr>
            <td>이름</td>
            <td>부서</td>
            <td>급여</td>
            <td>row_no</td>
            <td>rank_no</td>
            <td>dense_rank_no</td>
        </tr>
    </thead>
    <tbody style="text-align:center">
        <tr>
            <td>이현우</td>
            <td>개발</td>
            <td>5,200,000</td>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>강수진</td>
            <td>개발</td>
            <td>4,800,000</td>
            <td>2</td>
            <td>2</td>
            <td>2</td>
        </tr>
        <tr>
            <td>박민수</td>
            <td>개발</td>
            <td>3,650,000</td>
            <td style="border: 2px solid red;">3</td>
            <td style="border: 2px solid red;">3</td>
            <td style="border: 2px solid red;">3</td>
        </tr>
        <tr>
            <td>이영희</td>
            <td>개발</td>
            <td>3,650,000</td>
            <td style="border: 2px solid red;">4</td>
            <td style="border: 2px solid red;">3</td>
            <td style="border: 2px solid red;">3</td>
        </tr>
        <tr>
            <td>한성민</td>
            <td>개발</td>
            <td>2,700,000</td>
            <td style="border: 2px solid red;">5</td>
            <td style="border: 2px solid red;">5</td>
            <td style="border: 2px solid red;">4</td>
        </tr>
        <tr>
            <td>김하나</td>
            <td>영업</td>
            <td>3,700,000</td>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
    </tbody>
</table>

#### 특정 값에 대한 순위를 알고 싶다면?
```SQL
SELECT RANK(값) WITHIN GROUP (ORDER BY 컬럼);

-- 예시 (1반환)
SELECT RANK(96) WITHIN GROUP (ORDER BY MATH_SCORE DESC) AS 순위
FROM STUDENT;
```

- 여기서 RANK()는 윈도우 함수가 아닌 일반함수
- 특정값에 대한 순위를 반환
- 정렬 기준에 따라 순위가 바뀌니 정렬 컬럼 명시 필수

#### 순위 함수 특징
- 정렬 기준에 따라 순위가 달라지니 ORDER BY절 명시 필수
- 순위를 구할 대상을 ORDER BY절에 명시 (여러 개 명시 가능)
- 그룹 내 순위 구할 시 PRATITION BY 절 사용

### 행 순서 관련 함수
① LAG 와 LEAD (SQL Server 지원X)
- LAG : **이전 행의 값** 가져오기
- LEAD : **이후 행의 값** 가져오기

```SQL
-- 구문
SELECT LAG / LEAD (컬럼,                        -- 가져올 값의 컬럼
                   [N])                         -- 몇 번째 값을 가져올기 (DEFAULT : 1)
                   OVER([PARTITION BY 컬럼]     -- 행의 이동 그룸
                   ORDER BY 컬럼 [ASC | DESC]); -- 정렬컬럼

-- 예시
SELECT ENAME, HIREDATE, SAL,
        LAG(SAL) OVER(ORDER BY HIREDATE) AS 바로 직전 상사급여
```

|ENAME|HIREDATE|SAL|바로 직전 상사급여|
|---|---|---|---|
|ALLEN|1981-02-20|1600|NULL|
|WARD|1981-02-22|1250|1600|
|TURNER|1981-09-08|1500|1250|
|MARTIN|1981-09-28|1350|1500|

- 만약 그룹별 바로 직전상사의 급여를 가져오는 쿼리였다면 각 그룹별 첫 시작행은 NULL
- NULL을 없애고 싶다면 **LAG(SAL, N, NULL 대체값)**에서 3번째 인수로 대체값을 써주면 된다.

```SQL
SELECT ENAME, HIREDATE, SAL,
        LEAD(SAL) OVER(ORDER BY HIREDATE) AS RESULT
FROM EMP;
```

|ENAME|HIREDATE|SAL|RESULT|
|---|---|---|---|
|ALLEN|1981-02-20|1600|1250|
|WARD|1981-02-22|1250|1500|
|TURNER|1981-09-08|1500|1350|
|MARTIN|1981-09-28|1350|NULL|

② FIRST_VALUE, LAST_VALUE (SQL Server는 지원X)
- **정해진 범위에서 정렬 순서대로 처음 값, 마지막 값 출력**
- 순서와 범위 정의에 따라 최소값 / 최대값 반환 가능
- PARITION BY, ORDER BY 절 생략 가능

```SQL
SELECT ENAME, DEPTNO, SAL,
        FIRST_VALUE(SAL) OVER(PARTITION BY DEPTNO ORDER BY SAL) AS MIN,
        FIRST_VALUE(SAL) OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) AS MAX
FROM EMP;
```

|ENAME|DEPTNO|SAL|MIN|MAX|
|---|---|---|---|---|
|ALLEN|10|1300|1300|2750|
|WARD|10|1500|1300|2750|
|TURNER|10|2750|1300|2750|
|MARTIN|20|920|1800|
|SCOTT|20|1800|920|1800|

```SQL
SELECT ENAME, DEPTNO, SAL,
        FIRST_VALUE(ENAME) OVER(PARTITION BY DEPTNO ORDER BY SAL DESC
                                ROWS UNBOUNDED PRECEDING) AS ENAME_FV
FROM EMP;
```

|ENAME|DEPTNO|SAL|ENAME_FV|
|---|---|---|---|
|KING|10|5000|KING|
|CLARK|10|2450|KING|
|MILLER|10|1300|KING|
|SCOTT|20|3000|SCOTT|
|ADAMS|20|2700|SCOTT|

```SQL
SELECT ENAME, DEPTNO, SAL,
        LAST_VALUE(SAL) OVER(PARTITION BY DEPTNO ORDER BY SAL) AS V1
        LAST_VALUE(SAL) OVER(PARTITION BY DEPTNO ORDER BY SAL
                                RANGE BETWEEN UNBOUNDED PRECEDING
                                AND UNBOUNDED FOLLOWING) AS MAX,
        LAST_VALUE(SAL) OVER(PARTITION BT DEPTNO ORDER BY SAL DESC
                             RANGE BETWEEN UNBOUNDED PRECEDING
                             AND UNBOUNDED FOLLOWING) AS MIN
FROM EMP;
```

|ENAME|DEPTNO|SAL|V1|MAX|MIN|
|---|---|---|---|---|---|
|KING|10|1300|1300|5000|1300|
|CLARK|10|2450|2450|5000|1300|
|MILLER|10|5000|5000|5000|1300|
|SCOTT|20|950|950|3000|950|
|ADAMS|20|3000|3000|3000|950|

- LAST_VALUE()는 마지막 값을 가져오는 함수.
- 윈도우 함수의 연산 범위 DEFAULT값이 첫 행부터 현재 행이니 V1는 1300, 2450, 5000
- MAX의 경우 오름차순으로 정렬했을 때 현재 행부터 마지막 행까지에서 마지막 값을 가져오는 것
- MIN은 LAST_VALUE()시 마지막 값을 가져오게 되므로 정렬을 내림차순으로 해 마지막 값을 가장 작게 만들어 구하면 된다.

### NTILE(N) (SQL Server는 지원X)
- **행을 특정 컬럼 순서에 따라 정해진 수(N) 만큼 그룹으로 나누기 위한 함수**
- **ORDER BY 필수**
- 그룹별 번호가 반환됨
- PARTITION BY를 통해 특정 그룹을 원하는 수의 그룹만큼 분리 가능
- 총 행의 수가 나눠 떨어지지 않으면, 앞 그룹의 크기가 더 크게 분리됨
    - 14명을 3그룹으로 분리 → 그룹별로 5, 5, 4씩 나눠짐

```SQL
-- 구문
SELECT NTILE(N) OVER([PARTITION BY 컬럼]
                      ORDER BY 컬럼 ASC|DESC)
FROM 테이블명;

-- 예시
SELECT ENAME, SAL, DEPTNO,
        NTILE(2) OVER(ORDER BY SAL) AS GROUP_NO
FROM EMP;
```

|ENAME|SAL|DEPTNO|GROUP_NO|
|---|---|---|---|
|SMITH|800|20|1|
|JAMES|950|30|1|
|ADAMS|1100|20|1|
|WARD|1250|30|1|
|MARTIN|1250|30|1|
|MILLER|1300|10|1|
|||||
|ALLEN|1600|30|2|
|CLERK|2450|10|2|
|BLIKE|2800|30|2|

- 9행 / 2 = 4.5 => 5, 4인데 중복이 있어서 6,3

### ⭐ 비율 관련 함수 (SQL Server 지원X)
① RATIO_TO_REPORT
- **파티션 내 전체 SUM(컬럼)값에 한 행별 컬럼 값의 비율**
- 각 컬럼값(결과값) : 0 < 결과 <= 1
- PARTITION BY 명시하지 않는다면 데이터 전체 총계에서의 해당 컬럼 값의 비율
- **ORDER BY 사용불가**

```SQL
-- 구문
SELECT 컬럼,
        RATIO_TO_REPORT(컬럼) OVER([PARTITION BY 컬럼])
FROM 테이블명;

-- 예시
SELECT ENAME, SAL
        ROUND(RATIO_TO_REPORT(SAL) OVER(), 2) AS RATIO
FROM EMP
WHERE JOB = 'SALESMAN';
```

|ENAME|SAL|RATIO||
|---|---|---|---|
|ALLEN|1600|0.29|(1600/5000)|
|WARD|1250|0.22||
|TURNER|1250|0.22||
|MARTIN|1500|0.27||
|||합1||

② PERCENT_RANK
- **파티션별 윈도우에서 제일 먼저 나오는 것을 0(상위0%), 제일 늦게 나오는 것을 1로 하여, 값이 아닌 행의 순서별 백분율을 구한다.**
- PRTCENTILE(분위수)를 출력한다는 것
- 0 <= 결과 값 <= 1
- **ORDER BY 필수**

```SQL
-- 구문
SELECT 컬럼,
        PERCENT_RANK() OVER([PARTITION BY 컬럼]
                            ORDER BY 컬럼 ASC|DESC)
FROM 테이블명;

-- 예시
SELECT DEPTNO, ENAME, SAL,
        PERCENT_RANK() OVER (PRATITION BY DEPTNO ORDER BY SAL DESC) AS PR
FROM EMP;
```

|DEPTNO|ENAME|SAL|PR|(순위-1)/(총 행 개수-1)|
|---|---|---|---|---|
|10|KING|5000|0|(1-1)/(3-1) = 0.0|
|10|CLERK|2400|0.5|(2-1)/(3-1) = 0.5|
|10|MILLER|1300|1300|(3-1)/(3-1) = 1|
||||||
|20|SCOTT|3000|0|(1-1)/(5-1) = 0.0|
|20|FORD|3000|0|(1-1)/(5-1) = 0.0|
|20|JONES|2975|0.5|(3-1)/(5-1) = 0.5|
|20|ADAMS|1100|0.75|(4-1)/(5-1) = 0.75|
|20|SMITH|800|800|(5-1)/(5-1) = 1|

③ CUME_DIST
- 각 행의 수에 대한 **누적비율**
- 파티션별 윈도우의 전체건수에서 현재 행보다 작거나 같은 건수에 대한 누적배분율을 구함
- **ORDER BY 필수**
- ORDER BY를 통해 누적비율을 구하는 순서 정할 수 있음
- 0 < 결과 값 <= 1
- 한 파티션의 행이 3개면 첫 번째 행은 1/3 = 0.33

```SQL
SELECT DEPTNO, ENAME, SAL,
        CUME_DIST() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS PR
FROM EMP;
```

|DEPTNO|ENAME|SAL|CUME_DIST||
|---|---|---|---|---|
|10|KING|5000|0.3333|1/3지점|
|10|CLARK|2400|0.6667|2/3지점|
|10|MILLER|1300|1.0000|3/3지점|
||||||
|20|SCOTT|3000|0.4000|2/5지점|
|20|FORD|3000|0.4000|2/5지점|
|20|JONES|2975|0.6000|3/5지점|
|20|ADAMS|1100|0.8000|4/5지점|
|20|SMITH|800|1|5/5지점|

- 디폴트 범쉬가 RANGE라 같은 값을 가진 행을 같이 연산한다는 것
- 다르게 연산하길 원한다면 ROWS로 바꾸거나 ORDER BY에 컬럼을 하나 더 추가해서 다르게 취급

### ⭐ TOP N 쿼리
#### TOP N 쿼리
- 페이징 처리를 효과적으로 수행하기 위해 사용
- **전체 결과에서 데이터의 상위 N개 행을 추출**
    - 성적 상위자 3명

#### TOP-N 행 추출방법
① ROWNUM
- **출력된 데이터를 기준으로 행 번호가 부여**
- ORDER BY나 WHERE절로 데이터를 제한할 경우, 또 다른 순서가 그때 그때 부여됨
- **절대적인 행 번호가 아닌 가상의 번호라 특정 행을 지정할 수 없음**
- ROWNUM은 쿼리 결과에 순차적인 번호를 할당하며, WHERE 절에서 이를 제한할 수 있음
- 첫번째 행이 증가한 이후 할달되므로 '>'연산 사용 불가

```SQL
-- ROWNUM 출력 형태
SELECT ROWNUM, EMPNO, ENAME, SAL
FROM EMP
WHERE SAL >= 1500;
```

|ROWNUM|EMPNO|ENAME|SAL|
|---|---|---|---|
|1|7499|ALLEN|1600|
|2|7566|JONES|2975|
|3|7698|BLAKE|2850|
|4|7782|CLARK|2450|
||...|||

```SQL
-- ROWNUM의 잘못된 사용1
SELECT *
FROM EMP
WHERE ROWNUM > 1;
```

- 오류는 뜨지 않으나 아무 행도 반환하지 않음

#### 💡 원인
- 먼저, 쿼리가 FROM절에서 데이터를 읽어옴(아직 ROWNUM 부여X)
- 구 후, ROWNUM은 각 행이 하나씩 조회될 때마다 부여된다.
- 데이터의 첫 번째 행이 조회될 때 ROWNUM은 1이 되고, 두 번째 행이 조회될때 2, ...
- WHERE 절의 조건이 각 행 별로 적용되는데 ROWNUM이 부여되는 과정에서 WHERE 절 조건이 평가된다.
- 첫 번재 행이 조회될 때 ROWNUM = 1이 되는데, 이는 ROWNUM > 1 조건을 만족하지 않으므로 제외된다.
- 다음 행(두번째 행)이 또 ROWNUM = 1로 시작해서 다시 ROWNUM > 1 조건을 만족하지 않는다.
- 결국 모든 행이 조건을 통과하지 못하게 되어 아무 결과도 반환 안함
- **ROWNUM은 각 행을 하나씩 읽어오면서 부여되지에 WHERE절에서 ROWNUM에 대한 조건을 걸 때 ROWNUM = 1 값이 무조건 포함이 되어야 한다.**
- ROWNUM >= 1은 전체 데이터를 반환하는 것과 동일한 결과를 준다.

```SQL
-- ROWNUM의 잘못된 사용2
SELECT *
FROM EMP
WHERE ROWNUM = 3;
```

- 항상 불변하는 절대적 번호가 아니라 '=' 연산자 단독 전달 불가

```SQL
-- ROWNUM의 올바른 사용
SELECT ROWNUM, ENAME, SAL
FROM EMP
WHERE ROWNUM <= 3;
```

|ROWNUM|ENAME|SAL|
|---|---|---|
|1|SMITH|800|
|2|ALLEN|1600|
|3|WARD|1250|

- ROWNUM = 1부터 순서대로 데이터를 뽑을 수 있으니 출력 가능
- 정렬 순서에 따라 출력되는 ROWNUM은 달라짐

```SQL
-- 상위 급여자 3명 조회 (잘목된 쿼리)
SELECT ENAME, SAL
FROM EMP
WHERE ROWNUM <=3
ORDER BY SAL DESC;
```

|ENAME|SAL|
|---|---|
|ALLEN|1600|
|WARD|1250|
|SMITH|800|

- 얼핏 상위 3 급여자를 뽑은것 같지만, 급여 순서에 상관없이 무작위로 추출된 3명에 한해서 내림차순 정렬된 것이다.
    - **WHERE절이 ORDER BY절보다 먼저 수행되는 무작위에서 정렬한 것**

```SQL
-- 상위 급여자 3명 조회
SELECT ENAME, SAL
FROM (
    SELECT ENAME, SAL
    FROM EMP
    ORDER BY SAL DESC)
WHERE ROWNUM <=3;
```

|ENAME|SAL|
|---|---|
|KING|5000|
|SCOTT|3000|
|FORD|3000|

- 서브쿼리를 사용하여(인라인 뷰) 미리 내림차순으로 정렬을 해준다.
- **행별 ROWNUM이 결정되기 전에 미리 데이터 정렬을 해 둔 다음에 ROWNUM을 적용시키는 것**

```SQL
-- 상위 N ~ M까지의 행을 뽑고 싶다면
SELECT ENAME, SAL
FROM (
    SELECT * FROM EMP ORDER BY SAL DESC
)
WHERE ROWNUM BETWEEN 4 AND 6
ORDER BY SAL DESC;
-- ROWNUM = 1 이 정의되지 않았으니
-- 이를 건너띄고 그 다음 행에 대한 추출이 불가하다.

-- 인라인 뷰 결과에 ROWNUM을 미리 부여함으로서 해결
SELECT ENAME, SAL
FROM (
    SELECT ROWNUM AS RN, A.*
    FROM (SELECT ENAME, SAL
          FROM EMP
          ORDER BY SAL DESC) AS A
) AS B
WHERE ROWNUM BETWEEN 4 AND 6
ORDER BY SAL DESC;
```

② RANK
- 윈도우 함수의 RANK
- 동일한 값에 같은 순위 부여, 그 다음 순위는 건너뜀

```SQL
-- RANK를 이용해 원하는 순위 급여자 뽑기
SELECT ENAME, SAL
FROM (SELECT ENAME, SAL
             RANK() OVER (ORDER BY SAL DESC) AS RN
      FROM EMP) AS A
WHERE RN BETWEEN 4 AND 6
ORDER BY SAL DESC;
```

③ FETCH
- 출력될 행의 수를 제한하는 절
- ORACLE 12c 이상부터, SQL Server 사용가능
- ORDER BY절 뒤에 사용(내부 파싱 순서도 ORDER BY 뒤)

```SQL
-- 구문
SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY
OFFSET N { ROW | ROWS }
FETCH { FIRST | NEXT } N { ROW | ROWS } ONLY
```

- OFFSET N { ROW | ROWS }
    - 결과 집합에서 처음 N개의 행을 건너뛰고 그 다음 행부터 반환을 시작
    - N : 건너뛸 행의 수
    - ROW / ROWS : 행의 수에 다른 구분 (한 행[단수]/여러 행[복수] 구분하지 않아도 된다.)
- FETCH { FIRST | NEXT } N { RPW | ROWS } ONLY
    - OFFSET절에 의해 건너띈 행들 이후에 가져올 행의 개수를 지정
    - FIRST : OFFSET 사용하지 않았을 때, 처음부터 N 행 출력하라는 뜻
    - NEXT : OFFSET 사용했을 경우, OFFSET에서 제외한 행 다음부터 N행을 출력하라는 뜻
    - ONLY : 결과 제한을 의미하며 필수로 포함되어야 함

```SQL
-- 급여자 TOP 5
SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
ORDER BY SAL DESC
FETCH FIRST 5 ROWS ONLY;

-- 급여자 TOP 4,5,6 정보 출력
SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
ORDER BY SAL DESC
OFFSET 3 ROW
FETCH FIRST 3 ROW ONLY;
```

-- **FETCH FIRST, FETCH NEXT는 결과 동일함**

④ TOP N(SQL Server)
- SQL Server에서 상위 N개의 행 추출하는 문법
- 서브쿼리 사용없이 하나의 쿼리로 정렬된 순서대로 상위 N개의 데이터를 추출 가능함
- **WITH TIES를 사용해 동순위까지 함께 출력이 가능함**

```SQL
-- 구문
SELECT TOP N 컬럼1, 컬럼2, ...
FROM 테이블명
ORDER BY 정렬컬럼명 ASC|DESC;

-- TOP2 급여자
SELECT TOP 2 ENAME, SAL
FROM EMP
ORDER BY SAL DESC;
```

|ENAME|SAL|
|---|---|
|KING|5000|
|SCOTT|3000|

```SQL
-- TOP2 급여자(동순위도 출력)
SELECT TOP 2 WITH TIES ENAME, SAL
FROM EMP
ORDER BY SAL DESC;
```

|ENAME|SAL|
|---|---|
|KING|5000|
|SCOTT|3000|
|FORD|3000|

## ⭐ 계층형 질의와 셀프 조인
### 계층형 질의 (Hierarchical Query)
- 계층형 데이터를 조회하기 위해 사용
- 계층형 데이터 : 동일 테이블에 계층적으로 상/하위 데이터가 포함됨
    - 사원 테이블의 사원들 사이에 "하위 사원"과 "상위 사원(관리자)" 관계
- 엔터티를 순환관계 데이터 모델로 설계할 경우 계층형 데이터가 발생
    - 조직, 사원, 메뉴 등
- 하나의 테이블 내 각 행끼리 관계를 가질 때, 연결고리를 통해 행과 행 사이의 계층(DEPTH)을 표현하는 기법
    - 부서별 상하관계
- **PRIOR의 위치에 따라 연결하는 데이터가 달라짐**

```SQL
-- 구문
SELECT 컬럼
FROM 테이블명
START WITH 시작조건         -- 시작점 지정하는 조건
CONNECT BY [NOCYCLE] PRIOR 연결조건;
-- 시작점 기준으로 연결 데이터를 찾아가는 조건
```

- START WITH : 계층 구조 전개의 시작 위치 지절, 루트노드, 최상위 노드
    - **루트노드는 LEVEL 값으로 1을 가진다.**
- CONNECT BY PRIOR : 행을 이어나갈 조건
- NOCYCLE : A행 → B행, B행 → A행 같은 순환구조인 데이터는 무한 루프가 발생할 수 있어서 이를 방지하고자 할 때 사용

```SQL
-- 부서 테이블에 대해 각 부서의 레벨 출력
SELECT *, LEVEL
FROM DEPT
START WITH PDEPT IS NULL    -- PDEPT:상위부서코드
CONNECT BY PRIOR DCODE = PDEPT;
```

|DCODE|DNAME|PDEPT|LEVEL|
|---|---|---|---|
|0001|사장실||1|
|1000|경영지원부|0001|2|
|1001|재무관리|1000|3|
|1002|총무|1000|3|
|1003|기술부|0001|2|
|1004|H/W 지원|1003|3|
|1005|S/W 지원|1003|3|

- PRIOR 컬럼A = 컬럼B : 컬럼 위치 구분 법
- 시작점의 컬럼A를 읽고 그 값을 컬럼 B로 넘겨서 해당 조건이 일치하는 행을 찾은 것
- 만약 PRIOR PDEPT = DCODE : 시작점인 사장실 데이터에서 PDEPT 컬럼의 값을 먼저 읽게 되는데 이 경우 그 값이 NULL
    - DCODE 값이 NULL인 곳을 찾아야 하는데 그런 행은 없으니 연결이 될 수 없다.
- 사장실의 DCODE를 넘겨 다시 각 행들의 PDEPT와 비교해야 하므로 먼저 정해져야 하는 값의 방향에 PRIOR을 전달해야 한다.

```SQL
-- 잘못된 예시
SELECT *, LEVEL
FROM DEPT
START WITH PDEPT IS NULL
CONNECT BY DCODE = PRIOR PDEPT;
```

|DCODE|DNAME|PDEPT|LEVEL|
|---|---|---|---|
|0001|사장실||1|

- **PRIOR가 어디 위치하냐에 따라 출력되는 데이터가 다르니 주의**
- PRIOR 자식 = 부모 ~> [자식 → 부모] 자식에서 부모데이터로 **순방향** 전개
- PRIOT 부모 = 자식 ~> [부모 → 자식] 부모에서 자식데이터로 **역방향** 전개

```SQL
-- CONNECT BY에 조건 전달
SELECT *
FROM DEPT
START WITH PDEPT IS NULL
CONNECT BY PRIOR DCODE = PDEPT AND AREA = '서울지사';
```

|DCODE|DNAME|PDEPT|AREA|
|---|---|---|---|
|0001|사장식||포항본사|
|1000|경영지원부|0001|서울지사|
|1001|재무관리|1000|서울지사|
|1002|총무|1000|서울지사|

- AREA = '서울지사'라는 조건이 CONNECT BY 절에 쓰인거라 연결하려는 행을 찾는 조건에 쓰인 것
- 그래도 최상위노드인 사장실 데이터도 같이 출력된다.

```SQL
-- WHERE절에 조건 전달
SELECT *, LEVEL
FROM DEPT
WHERE AREA = '서울지사'
START WITH PDEPT IS NULL
CONNECT BY PRIOR DCODE = PDEPT;
```

|DCODE|DNAME|PDEPT|AREA|LEVEL|
|---|---|---|---|---|
|1000|경영지원부|0001|서울지사|2|
|1001|재무관리|1000|서울지사|3|
|1002|총무|1000|서울지사|3|

- **WHERE절은 START WITH ... CONNECT BY ... 계층형 질의절이 모두 연산된 다음에 수행됨**
- 서울지사가 아닌 사장실 데이터가 출력에서 제외되었다.

### 계층형 질의 가상 컬럼
- LEVEL : 검색 항목 데이터의 깊이, 루프노드(최상위 계층): 1
- CONNECT_BY_ISLEAF : 리프노드(최하위 계층)여부
    - 해당 데이터가 **리프노드라면 1, 아니면 0 반환**

### 계층형 질의 가상 함수
- CONNECT_BY_ROOT 컬럼 : 최상위(루프노드) 계층의 컬럼값 표시
- SYS_CONNECT_BY_PATH(컬럼, 경로분리자) : 루트 데이터부터 현재 전개할 데이터까지 경로를 표시
- ORDER SIBLINGS BY 컬럼 : **형제 노드(동일 LEVEL) 사이에서 정렬 수행**
- CONNECT_BY_ISCYCLE : 계층형 쿼리의 결과에서 순환이 발생했는가
    - 자식 데이터와 조상 데이터가 같으면 1, 아니면 0 반환

```SQL
SELECT CONNECT_BY_ROOT 사원 AS 루트사원,
        SYS_CONNECT_BY_PATH(사원, '/') 경로, 사원, 관리자
FROM 사원
START WITH 관리자 IS NULL
CONNECT BY PRIOR 사원 = 관리자
```

|루트사원|경로|사원|관리자|
|---|---|---|---|
|A|/A|A||
|A|/A/B|B|A|
|A|/A/C|C|A|
|A|/A/C/D|D|C|

</br>

- 순환구조 예시 테이블-EMP1

|EMP_ID|DEPTNO|MGR_ID|NAME|
|---|---|---|---|
|1000|10|2000|홍길동|
|2000|10|1000|강감찬|

```SQL
-- NOCYCLE 명시 X
SELECT EMP_ID, NAME, LEVEL
FROM EMP1
START WITH EMP_ID = 1000
CONNECT BY PRIOR EMP_ID = MGR_ID;   -- 오류
-- 순환구조를 가진 데이터인데 NOCYCLE 명시하지 않아 오류
```

```SQL
-- NOCYCLE 명시 O
SELECT EMP_ID, NAME, LEVEL,
        CONNECT_BY_ISCYCLE AD IS_CYCLE
FROM EMP1
START WITH EMP_ID = 1000
CONNECT BY NOCYCLE PRIOR EMP_ID = MGR_ID;
```

|EMP_ID|NALME|LEVEL|IS_CYCCLE|
|---|---|---|---|
|1000|홍길동|1|0|
|2000|강감찬|2|1|

## PIVOT절과 UNPIVOT절 '데이터 구조를 변경하는 기능'
### 데이터 구조
① Long Data (Tidy Data) '통계 분석용'
- 하나의 속성이 하나의 컬럼으로 정의되어 값들이 여러 행으로 쌓이는 구조
- 동일한 키 값이 여러 번 반복될 수 있음
- RDBMS의 데이터 설계 방식
- 다른 테이블과의 조인 연산이 가능
- 각 행이 관찰 단위를 나타냄
- 각 열은 측정 변수 또는 속성을 나타냄

|ID|YEAR|SALES|
|---|---|---|
|1|2022|100|
|1|2023|120|
|2|2022|150|
|2|2023|130|

② Wide Data (Cross Table) '단순 보고서 작성이나 데이터 요약용'
- 행과 컬럼에 유의미한 정보 전달을 목적으로 작성하는 교차표
- 하나의 속성값이 여러 컬럼으로 분리되어 표현
- 데이터 많아질수록 열의 수가 급격히 늘어나니 분석을 위해선 비효율
- 다른 테이블과 조인 연산 불가능

|ID|2022|2023|
|---|---|---|
|1|100|120|
|2|150|130|

### 데이터 구조 변경
- PIVOT : Long Data → Wide Data '행 데이터를 열 데이터로'
- UNPIVOT : Wide Data → Long Data '열 데이터를 행 데이터로'

### PIVOT
```SQL
SELECT *
FROM (
    SELECT E.JOB, D.DNAME
    FROM EMP E
    JOIN DEPT D
    ON E.DEPTNO = D.DEPTNO
)
PIVOT (
    COUNT(*) FOR DNAME IN (
        'ACCOUNTING' AS ACCOUNTING,
        'RESEARCH' AS RESEARCH,
        'SALES' AS SALES
    )
);
```

|JOB|ACCOUNTING|RESEARCH|SALES|
|---|---|---|---|
|CLERK|0|1|0|
|SALESMAX|1|0|3|
|MANAGER|1|1|1|
|ANALYST|0|2|0|

### UNPIVOT
```SQL
SELECT JOB, DEPARTMENT, EMP_COUNT
FROM PIVOT_TABLE
UNPIVOT(
    EMP_COUNT FOR DEPARTMENT IN (
        ACCOUNTING AS 'ACCOUNTING'
        RESEARCH AS 'RESEARCH'
        SALES AS 'SALES'
    )
);
```

|JOB|DEPARTMENT|EMP_COUNT|
|---|---|---|
|CLERK|ACCOUNTING|0|
|CLERK|RESEARCH|1|
|CLERK|SALES|0|
|SALESMAN|ACCOUNTING|1|
|SALESMAN|RESEARCH|0|
|SALESMAN|SALES|3|
|MANAGER|ACCOUNTING|1|
|MANAGER|RESEARCH|1|
|MANAGER|SALES|1|
|ANALYST|ACCOUNTING|0|
|ANALYST|RESEARCH|2|
|ANALYST|SALES|0|

## 정규 표현식
### 정규 표현식
- 문자열의 공통된 규칙을 보다 일반화하여 표현하는 방법
    - 공통적으로 가지고 있는 패턴을 표현하는 방법
- 정규 표현식 사용 가능한 문자함수 제공
    -  오라클: regeex_replace, regexp_substr, regexp_instr, ...
- 특정 패털을 가진 문자열을 검색, 매칭, 또는 수정할 때 사용하는 매우 강력한 도구
- **텍스트 데이터 안에서 특정 규칙을 정의해, 이를 만족하는 문자열을 찾아내는데 유용**

### 정규 표현식의 종류
- 정규 표현식의 기본 연산자

|연산자|영문|설명|
|---|---|---|
|.|dot|모든 한 글자(제외:newline)|
|\||or|대체문자를 구분|
|\ |backslash|다음 문자를 일반 문자로 취급|

|앵커|설명|
|---|---|
|^|시작되는 글자|
|$|마지막 글자|

- 수량사

|연산자|설명|
|---|---|
|?|0회 또는 1회 일치|
|*|0회 이상 일치|
|+|1회 이상 일치|
|{m}|m회 일치|
|{m,}|최소 m회 일치|
|{,m}|최대 m회 일치|
|{m,n}|최소 m회일지, 최대 n회 일치|
|[char...]|문자 리스트 중 한 문자와 일치|
|[^char...]|문자 리스트에 포함되지 않은 한 문자와 일치|

|연산자|설명|동일|
|---|---|---|
|[:digit:]|숫자|[0-9]|
|[:lower:]|소문자|[a-z]|
|[:upper:]|대문자|[A-Z]|
|[:alpha:]|영문자|[a-zA-Z]|
|[:alnum:]|영문자와 숫자|[0-9a-zA-Z]|
|[:xdigit:]|16진수|[0-9a-fA-F]|
|[:punct:]|구두점 기호|[^[:alnum:][:cntrl:]]|
|[:blank:]|공백 문자||
|[:space:]|공간 문자(space, enter, tab)||
||||
|\d|숫자|[[:digit:]]|
|\D|숫자가 아닌 모든 문자|[^[:digit:]]|
|\w|숫자와 영문자(underbar 포함)|[[:alnum:]_]|
|\W|숫자와 영문자가 아닌 모든 문자(제외:underbar)|[^[:alnum:]_]|
|\s|공백 문자|[[:space:]]|
|\S|공백 문자가 아닌 모든 문자|[^[:space:]]|

### ⭐ 정규 표현식 함수
① REGEXP_LIKE 조건
- source_char가 패턴과 일치하면 true, 일치하지 않으면 false 반환

```SQL
REGEXP_LIKE(
    source_char, 
    pattern, 
    [, match_param])
```

- source_char : 검색 문자열
- pattern : 검색 패턴
- match_param : 일치 옵션(기본값:c)
- 일치옵션
    - i : 대소문자 무시
    - c : 대소문자 구분
    - n : dot(.)를 개행(줄바꿈) 문자와 일치
    - m : 다중 행 모드 (앵커(^,$)에 영향)
    - x : 검색 패턴의 공백 문자를 무시

② REGEXP_REPLACE 함수
- source_char에서 일치한 패턴을 replace_string으로 변경한 문자 값을 반환

```SQL
REGEXP_REPLACE(
    source_char, 
    pattern 
    [, replace_string 
    [, position 
    [, occurrence 
    [, match_param]]]])
```

- source_char : 검색 문자열
- pattern : 검색 패턴
- replace_string : 변경 문자열
- position : 검색 시작 위치 (기본값:1)
- occurrence : 패턴 일치 횟수 (기본값:1)
- match_param : 일치 옵션

③ REGEXP_SUBSTR 함수
- source_char에서 일치한 pattern을 반환

```SQL
REGEXP_SUBSTR(
    source_char,
    pattern 
    [, position 
    [, occurence 
    [, match_param 
    [, subexpr]]]]
)
```

- source_char : 검색 문자열
- pattern : 검색 패턴
- position : 검색 시작 위치 (기본값:1)
- occurrence : 패턴 일치 횟수 (기본값:1)
- match_param : 일치 옵션
- subexpr : 서브표현식 (0은 전체패턴, 1이상은 서브 표현식, 기본값은 0)

④ REGEXP_INSTR 함수
- source_char에서 일치한 pattern의 시작 위치를 정수로 반환

```SQL
REGEXP_INSTR(
    source_char,
    pattern
    [, position 
    [, occurence 
    [, return_opt 
    [, match_param 
    [, subexpr]]]]]
)
```

- source_char : 검색 문자열
- pattern : 검색 패턴
- position : 검색 시작 위치 (기본값:1)
- occurrence : 패턴 일치 획수 (기본값:1)
- return_opt : 반환 옵셩 (0은 시작위치, 1은 다음위치, 기본값은 0)
- match_param 일치 옵션
- subexpr : 서브표현식 (0은 전체패턴, 1이상은 서브 표현식, 기본값은 0)

⑤ REGEXP_COUNT 함수
- source_char에서 일치한 pattern의 횟수를 반환

```SQL
REGEXP_COUNT(
    source_char, 
    pattern 
    [, position 
    [, match_param]])
```

- source_char : 검색 문자열
- pattern : 검색 패턴
- position : 검색 시작 위치 (기본값:1)
- match_param : 일치 옵션


<br />

📖 Reference
- [2024 개념정리](https://bruders.tistory.com/)




