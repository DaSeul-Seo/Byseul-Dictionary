## DML (Data Manipulation Language)
### DML
- 만들어진 테이블에 관리하기를 원하는 자료들을 입력, 수정, 삭제, 조회하는 명령어
- 데이터 입력(INSERT), 수정(UPDATE), 삭제(DELETE), 조회(SELECT)
- 추가: 병합(METGE)
- **COMMIT, ROLLBACK 필수**

### INSERT
```SQL
-- 원하는 컬럼에만 데이터 입력
INSERT INTO 테이블명 (열1, 열2, 열5, 열7) VALUES (값1, 값2, 값5, 값7)
-- 전체 컬럼에 데이터 입력
INSERT INTO 테이블명 VALUES (값1, 값2, 값3, ... 값n)
```

- 테이블에 행 데이터 삽입
- ORACLE : 한 번에 한 행만 입력 가능
- SQL Server : 여러 행 동시 삽입 가능
- 컬럼별 데이터 타입과 사이즈에 맞게 하나의 값만 삽입
- 일부 컬럼만 입력도 가능
    - 작성하지 않은 컬럼은 NULL 입력됨
    - NOT NULL이 제약조건인 컬럼인 경우, 오류발생
- 문자 컬럼에 숫자값을 입력해도 오류는 뜨지 않으나 권고하지는 않음
- ORACLE에서 '' 데이터를 삽입하면 NULL로 입력됨
    - 해당 데이터를 조회하려면 IS NULL 조건을 사용해야 함
- SQL Server에서 '' 데이터를 삽입하면 아무것도 입력X (NULL 입력 아님)
    - 해당 데이터를 조회하려면 = ''라 입력해야 함

### UPDATE
```SQL
UPDATE 테이블명
SET 수정할컬럼1 = 수정값1, 수정할컬럼2 = 수정값2, ...
WHERE 조건;
```

- 데이터 수정 수행
- 컬럼 단위 수행
- **다중컬럼 수정 가능**
- SET에 수정할 컬럼과 새로 넣어줄 값을 설정
- WHERE 절에 수정할 행을 선택하는 조건 입력
    - 조건을 지정해주지 않으면 모든 행들이 수정됨

```SQL
-- 서브쿼리를 사용한 데이터 수정
UPDATE 테이블명
SET (수정할컬럼1, 수정할컬럼2, ...) = (수정값1, 수정값2, ...)
WHERE 조건;

-- 예시
UPDATE EMP
SET (SAL, COMM) = (SELECT AVG(SAL), AVG(COMM)
                    FROM EMP)
WHERE ENAME = 'John';
```

- 서브쿼리의 결과가 수정할 각 행의 값마다 하나씩 전달된다.
    - 수정할 컬럼 개수만큼 수정값이 있어야 한다.

### DELETE
```SQL
DELETE [FROM] 테이블명
WHERE 조건;
```

- 데이터 삭제 수행
- 행 단위 실행
- 조건을 붙이지 않은 경우, 테이블에 존재하는 모든 데이터가 삭제됨

### 주의
- DB는 DDL명령어와 DML명령어의 처리 방식에는 차이가 있다.
- DDL
    - 직접 DB에 영향을 미쳐 DDL 명령어를 입력하는 순간 해당 작업이 즉시(AUTO COMMIT) 완료된다.
- DML
    - 조작하려는 테이블을 메모리 버퍼에 올려놓고 작업을 해서 실시간으로 테이블에 영향을 미치는 것이 아니다.
    - 버퍼에서 처리한 DML 명령어가 실제 테이블에 반영되지 위해서는 COMMIT 명령어를 입력해 TRANSACTION을 종료해야 한다.
- SQL Server는 DML도 AUTO COMMIT으로 처리됨

### MERGE
```SQL
MERGE INTO 수정할테이블 AS TGT
USING 참조테이블 AS SRC
ON (연결조건)    -- 괄호 필수
WHEN MATCHED THEN
    UPDATE      -- 테이블명 생략
    SET 수정내용
    DELETE (조건)   -- 괄호 생략 가능
WHEN NOT MATCHED THEN
    INSERT (컬럼1, 컬럼2, ...)
    VALUES (값1, 값2, ...)
```

- 데이터 병함
- 참조테이블의 데이터를 기준으로 다른 테이블을 수정하는 것
- 참조테이블과 동일하게 맞추는 작업
- **UPDATE와 DELETE, INSERT를 한 전의 작업으로 수행 가능**

```SQL
MERGE INTO TEAM T
USING MEMBER M
ON (T.member_id = M.member_id)
WHEN MATCHED THEN
    UPDATE SET T.name = M.name, T.email = M.email
WHEN NOT MATCHED THEN
    INSERT (team_id, name, email)
    VALUES (M.member_id, M.name, M.email);
```

### SELECT
```SQL
SELECT [ALL/DISTINCT] 칼럼명
FROM 테이블명;
```

### 산술 연산자
- NUMBER와 DATE 자료형에 적용
- 수학에서 사칙연산
- 수학에서와 같이 (), *, /, +, - 의 우선순위를 가짐

### 합성 연산자
```SQL
-- (1) || (ORACLE)
SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME
FROM EMPLOYEES;
-- (2) + (SQL Server)
SELECT FIRST_NAME + ' ' + LAST_NAME AS FULL_NAME
FROM EMPLYEES;
-- (3) CONCAT
SELECT CONCAT('Hello, ', 'World!') AS greeting;
```

- 컬럼과 문자 또는 다른 컬럼을 연결시킨다.
- 문자 표현식의 결과에 의해 새로운 컬럼을 생성한다.

```SQL
SELECT PLAYER_NAME + '선수, ' + HEIGHT + 'cm, ' + WEIGHT + 'kg'

-- 실행결과
안대현선수, 179cm, 72kg
```

## TCL (Transaction Control Language)
### TCL
- 트랜잭션 제어어로 COMMIT, ROLLBACK, SAVEPOINT 포함
- **DML에 의해 조작된 결과를 작업단위(트랜잭션)별로 제어**

### 트랜잭션
- 데이터베이스의 **논리적 연산단위**
- **⭐분할할 수 없는 최소의 단위**
    - 전부 적용하거나 전부 취소해야 함(ALL OR NOTHING)
    - 모두가 COMMIT하거나 ROLLBACK 처리해야 함
    - Ex) 계좌이체는 하나의 계좌에서는 금액이 빠지고 다른 하나의 계좌에서는 금액이 더해지는 일이 모두 성공적으로 완료가 되었을 때 종료된다. 하나라도 실패할 경우 두 계좌를 원래의 금액을 유지해야만 한다.

### ⭐ 트랜잭션의 특징
① 원자성(Atomicity)
- 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던가 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다. (ALL OR NOTHING)

② 일관성(Consistency)
- 트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못되어 있지 않다면, 트랜잭셩이 실행된 이후에도 데이터베이스의 내용이 잘못이 있으면 안된다.

③ 고립성(Isolation)
- 트랜잭션이 실행되는 도중에 다른 트랜잭셩의 영향을 받아 잘못된 결과를 만들어서는 안된다.

④ 지속성(Durability)
- 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용을 영구적으로 저정된다.

### COMMIT
- **올바르게 반영된 데이터를 데이터베이스에 반영시키는 것**
- 입력, 수정, 삭제한 데이터에 이상이 없을 시 데이터를 저장하는 명령어
- **COMMIT을 수행하면 COMMIT이전에 수행된 DML은 모두 저장되며 되돌릴 수 없음**
- ORACLE : DDL시 AUTO COMMIT (23c 버전부터 비활성화 가능)
- SQL Server : AUTO COMIT 비활성화 설정 가능

### SQL Server의 COMMIT
- ORACLE : DML시 사용자가 COMMIT / ROLLBACK 수행해야 트랜잭션 종료
- SQL Server : 기본적으로 AUTO COMMIT 모드라 DML 수행 후 사용자가 COMMIT / ROLLBACK 처리할 필요 없음
- DML 구문이 문제 없으면 자동 COMMIT되고, 오류 발생 시 자동 ROLLBACK 처리됨

### SQL Server의 3가지 트랜잭션 방식
① AUTO COMMIT
- SQL Server의 기본방식으로, DML, DDL명령어가 성공적으로 수행되면 자동 COMMIT 수행, 오류발생 시 자동 ROLLBACK 수행

③ 암시적 트랜잭션
- ORACLE과 같은 방식으로 처리
- 사용자가 명시적으로 COMMIT / ROLLBACK 처리
- 인스턴스 단위 또는 세션 단위로 설정 가능

③ 명시적 트랜잭션
- 트랜잭셩의 시작과 끝을 모두 사용자가 명시적으로 지정
- BEGIN TRANSACTION (BEGIN TRAN)으로 트랜잭셩을 시작
- COMMIT TRANSACTION 또는 ROLLBACK TRANSACTION으로 트랜잭션을 종료 (TRANSACTION 생략 가능)
- ROLLBACK 구문 만나면 최초의 BEGIN TRANSACTION 시점까지 모두 ROLLBACK 수행

### ROLLBACK
- 테이블 내 입력한 데이터나 수정한 데이터, 삭제한 데이터에 대하여 변경을 취소하는 명령어
- **데이터베이스에 저장되지 않고 최종 COMMIT 지점 / 변경 전 /  특정 SAVEPOINT 지점으로 원복됨**
- **최종 COMMIT 시점 이전까지 ROLLBACK 가능**
- SAVEPOINT를 통해 최종 COMMIT 시점이 아닌, 원하는 시점으로 원복이 가능
- SQL Server는 AUTO COMMIT이 기본 방식이라 임의적으로 ROLLBACK 수행하려면 명시적으로 트랜잭션을 선언해야 함

```SQL
-- ORACLE
UPDATE PLAYER
SET PRICE = 2800
WHERE DRINK = '아메리카노';

ROLLBACK;

-- SQL Server
BEGIN TRAN
UPDATE PLAYER
SET PRICE = 2800
WHERE DRINK = '아메리카노';

ROLLBACK;
```

### COMMIT과 ROLLBACK을 통한 효과
- 데이터 무결성 보장
- 영구적인 변경을 하기 전에 데이터의 변경 사항 확인 가능
- 논리적으로 연관된 작업을 그룹핑하여 처리 가능

💡 정리
```SQL
UPDATE A SET VAL = 10;      -- DML : 트랜잭션 시작
CREATE TABLE B (ID CHAR(3) PRIMARY KEY);    -- DDL : 자동 커밋 발생
INSERT INTO B VALUES ('1'); -- DML : 새로운 드랜잭션
ROLLBACK;
```

- ORACLE에서 DDL명령어(CREATE TABLE, ALTER TABLE 등)가 실행되면, 해당 DDL 이전에 수행된 모든 DML 작업이 자동으로 커밋된다.
- DDL이 발생하기 전까지의 모든 트랜잭션이 커밋되고, 이후부터는 새로운 트랜잭셩이 시작되는 것

### SAVEPOINT(저장점)
- SAVEPOINT를 통해 트랜잭션에 포함된 전체 작업을 롤백하는 것이 아니라 **현 시점에서 SAVEPOINT까지 트랜잭션의 일부만 롤백 가능**
- 사용자가 원하는 위치에 원하는 이름으로 설정 가능
- **ROLLBACK TO SAVEPOINT로 원하는 지점으로 원복가능 (COOMIT 이전으로는 원복 불가)**
- 복수의 SAVEPOINT를 정의할 수 있고, 동일이름으로 정의했을 시, 나중에 정의한 저장점이 

```SQL
-- ORABLE
SAVEPOINT A;
ROLLBACK TO A;

-- SQL Server
SAVE TRANSACTION A;
ROLLBACK TRANSACTION A;
```

```SQL
SELECT COUNT(*)
FROM PLAYER;    -- 결과: 400

SELECT COUNT(*)
FROM PLAYER
WHERE WEIGHT = 100;     -- RUFRHK: 0

INSERT INTO PLAYER
(PLAYER_ID, TEAM_ID, PLAYER_NAME, POSITION, HEIGHT, WEIGHT)
VALUES ('135', 'K02', '이운재', 'GK', 182, 82);

SAVEPOINT SVPT_A;
-----------------------------
UPDATE PLAYER
SET WEIGHT = 100;

SAVEPOINT SVPT_B;
-----------------------------
DELETE FROM PLAYER;
```

- CASE1: ROLLBACK TO SVPT_B = PLAYER 삭제되기 전으로
- CASE2: ROLLBACK TO SVPT_A = 선수들의 몸무게가 전부 100KG 되기 전으로
- CASE3: ROLLBACK: 이운재 선수가 추가되기 전으로

## DDL (Data Definition Language)
### 데이터 유형 (앞: ORACLE, 뒤: SQL Server)
- CHAR(n)
    - 고정 길이 문자열
    - 할당된 변수 값의 길이가 n이하면 n만큼 공백으로 채워짐
    - CHAR(5)인데 'Lee'라는 3바이트 글자를 넣으면 부족한 자리만큼 공백으로 채워 5바이트로 저장됨
    - 문자열 비교 방식 : 'AA' = 'AA '
- VARCHAR2(n), VARVHAR(n)
    - 가변 길이 문자열
    - 할당되는 변수 값의 길이가 최대 n
    - VARCHAR(15)로 15바이트가 지정되더라도 'Park'으로 데이터 입력되면 4바이트의 공간만 차지
    - 문자열 비교 방식 : 'AA' != 'AA '
- NUMBER(p,s), NUMBERIC(p,s)
    - 정수, 실수 등 숫자 정보
    - NUMBER(6,2) : 전체 자리수가 6이고 소수 자리 수는 2인 숫자
        - 1234.56(가능)
        - 12345.67(오류!)
- DATE, DATETIME
    - 날짜와 시각 정보

### DDL
- 데이터 정의어
- **데이터의 구조를 정의** (객체 생성, 삭제, 변경)
- CREATE(객체 생성), ALTER(객체 변경), TRUNCATE(테이블 내 모든 데이터 삭제, 테이블 삭제X)
- 스키마, 도메인, 테이블, 뷰, 인덱스를 정의/변경/제거할 때 사용
- **AUTO COMMIT이라 ROLLBACK 불가**
- TRUNCATE가 데이터 삭제라 DML에 껴야 할 것 같지만 AUTO COMMIT 특성 때문에 DDL에 포함

### CREATE
```SQL
CREATE TABLE [소유자.]테이블명 (
    컬럼1 데이터타입 [DEFAULT] [제약조건],
    컬럼2 데이터타입 [DEFAULT] [제약조건],
    ...
);
```

- 테이블, 인덱스 등의 객체를 생성하는 명령어
- 테이블 생성 시 각 컬럼의 제약조건 및 기본값을 생략 가능
- 테이블 생성 시 소유자 명시 가능 (생략 시 명령어 수행 계정의 소유)
- 숫자 컬럼의 경우, 컬럼 사이즈 생략 가능 (날짜 컬럼은 사이즈 명시 X)
- 테이블 생성 시 대/소문자 구분 X (기본적으로 테이블명, 컬럼명은 대문자)

### ⭐ 테이블 생성시 주의사항
- 테이블명은 객체를 의미할 수 있는 적절한 이름 사용, 단수형 권고
- 테이블명은 다른 테이블명과 중복되지 않아야 함
- 한 테이블 내에서는 컬럼명은 중복될 수 없음
- 테이블명을 지정하고 각 컬럼은 괄호 "()"로 묶어 지정
- 각 컬럼들은 콤마 ","로 구분되고, 테이블 생성문의 끝은 항상 세미콜론 ";"으로 끝남
- 컬럼에 대해서는 다른 테이블까지 고려하여 데이터베이스 내에서는 일관성 있게 사용하는 것이 좋음
- 컬럼 뒤에 데이터 유형은 꼭 지정되어야 함
- **⭐테이블명과 컬럼명은 반드시 문자로 시작해야 함**
- 벤더에서 사전에 정의한 예약어는 사용불가
- A-Z, a-z, 0-9, _, $, # 문자만 허용됨

### 테이블 복제 (CTAS) '이미 만들어진 테이블을 활용해서 테이블 재생성'
```SQL
-- ORACLE
CREATE TABLE 테이블명
AS 
SELECT * FROM 복제할 테이블명;

-- SQL Server
SELECT * INTO 테이블명
FROM 복제할 테이블명;
```

- 복제할 테이블의 컬럼명과 컬럼의 데이터 타입이 복제됨
- SELECT 문에서 컬럼 별칭 사용 시, 컬럼 별칭으로 이름 생성
- CREATE 문에서 컬럼명 변경 가능
- NULL 속성도 복제됨
- **구조 뿐만 아니라 데이터도 복제가 되니** WHERE 절을 명시해서 일부 데이터만 제한해서 복제하는 것도 가능
- **테이블에 있는 기본키, 고유키, 외래키, CHECK 등의 제약 조건은 복제 X**
    - **기존 테이블의 제약조건 중 NOT NULL만 복제 적용됨.**

```SQL
-- 테이블 생성
CREATE TABLE BOOK(
    ID VARCHAR2(10),
    NAME VARCHAR2(100),
    PRICE NUMBER,
    PUBLISHER_DATE DATE
);

-- 테이블 복제
CREATE TABLE test
AS
SELECT * FROM BOOK;

-- 데이터 없이 테이블의 구조만 복제
CREATE TABLE test
AS
SELECT * FROM BOOK
WHERE 1 = 2;    -- WHERE에 거짓인 조건으로 데이터는 가져오지 않고 구조만 복사

-- 테이블 복제 시 칼럼명 변경
CREATE TABLE test(BOOK_ID, BOOK_NAME)
AS
SELECT ID, NAME
FROM BOOK;
```

### 생성된 테이블 구조 확인
```SQL
-- ORACLE
DESCRIBE EMPLOYEES; -- DESC로 생략 가능

-- SQL Server
exec sp_help 'dbo.EMPLOYEES'
go
```

### ALTER
```SQL
ALTER TABLE 테이블명 ADD 컬럼명 데이터 유형             -- 컬럼 추가
ALTER TABLE 테이블명 MODIFY 컬럼명                     -- 컬럼 수정
ALTER TABLE 테이블명 RENAME COLUMN 컬럼명 TO 새컬럼명   -- 컬럼명 변경
ALTER TABLE 테이블명 DROP COLUMN 컬럼명                 -- 컬럼 삭제
ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명         -- 제약조건 삭제
ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건   -- 제약조건 추가
```

- 테이블 구조 변경
    - 컬럼명, 컬럼 데이터타입, 컬럼사이즈, DEFAULT값, 컬럼 삭제, 컬럼 추가, 제약조건 정의
- 컬럼 순서 변경은 불가능 (순서 변경 원할 시 테이블 재생성해야 함)

### 컬럼 추가
```SQL
-- 구문
ALTER TABLE 테이블명 ADD 컬럼명 데이터 타입 [DEFAULT] [제약조건];

-- 예시
ALTER TABLE PLAYER ADD ADDRESS VARCHAR2(50);
ALTER TABLE PLAYER ADD (ADDRESS VARCHAR2(50));
ALTER TABLE PLAYER ADD (BIRTHDAY DATE, ADDRESS VARCHAR2(80)); 
ALTER TABLE PLAYER ADD BIRTHDAY DATE, ADDRESS VARCHAR2(80); -- 오류
ALTER TABLE PLAYER ADD BIRTHDAY DATE NOT NULL; -- 불가능

ALTER TABLE PLAYER
ADD STADIUM VARCHAR2(25)
DEFAULT '전주월드컵경기장' NOT NULL;    -- 가능
```

- 새로 추가된 컬럼은 테이블의 마지막 컬럼이 되며 위치 지정 불가
- 컬럼 추가 시 데이터타입 필수
- DEFAULT와 제약조건은 필수 X
- **여러 컬럼 동시 추가도 가능 (이때 반드시 괄호 사용)**
- 이미 테이블에 데이터들이 들어가 있는 경우 NOT NULL의 속성을 가진 새 컬럼의 추가는 불가능
    - 기존 데이터들이 해당 컬럼의 속성값으로 전부 NULL을 가지게 되므로
    - 데이터가 아직 없는 경우에는 상관없다.
    - 컬럼 추가 시 DAFAULT 값을 지정해주면 NOT NULL 속성을 가진 새 컬럼 추가 가능

### 컬럼 속성 변경/수정
```SQL
-- ORACLE
ALTER TABLE 테이블명
MODIFY (칼럼명1 데이터유형 [DEFAULT] [NOT NULL],
        칼럼명2 데이터유형, ...);

-- SQL Server = 한 번에 하나의 컬럼만 수정 가능
ALTER TABLE 테이블명
ALTER COLUMN 컬럼명1 데이터유형 [DEFAULT] [NOT NULL];
ALTER TABLE 테이블명
ALTER COLUMN 컬럼명2 데이터유형 [DEFAULT] [NOT NULL];
```

- 수정할 컬럼이 한 개일 경우 괄호 생략 가능
- 테이블에 이미 존재하는 컬럼에 대해서 컬럼의 데이터 유형, DEFAULT 값, NOT NULL 제약조건에 대한 변경 가능

#### 컬럼 사이즈 변경
```SQL
-- ORACLE
ALTER TABLE TEST MODIFY (COL1 VARCHAR2(50));
-- SQL Server
ALTER TABLE TEST ALTER COLUMN COL1 VARCHAR(50);
```

- 컬럼 사이즈 증가는 항상 가능
- 컬럼 사이즈 축소는 데이터 존재 여부에 따라 제한됨
    - 데이터가 있는 경우, 데이터의 최대 사이즈만큼 축소 가능

#### 데이터 타입 변경
```SQL
-- VARCHAR2(10) 속성을 가진 DEPTNO
ALTER TABLE EMP MODIFY DEPTNO NUMBER(3);
-- 아직 DEPTNO 컬럼에 데이터가 없을 경우 변경 가능
```

- **컬럼이 NULL 값만 가지거나 데이터가 비어져 있는 컬럼이면 데이터 타입 변경 가능**
- CHAR, VARCHAR 타입인 경우 데이터가 있어도 서로 변경 가능

#### DEFAULT 값 변경
```SQL
ALTER TABLE EMP MODIFY (SAL DEFAULT 2500);
```

- DEFAULT 값: 특정 컬럼에 값을 지정하지 않은 경우 자동으로 부여되는 값
- **NULL 값을 넣는다면 DEFAULT값이 아닌 NULL이 입력됨 (NULL도 값이니까)**
- **이미 데이터가 존재하는 특정 컬럼의 DEFAULT값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미친다.**
    - 기존 데이터는 수정 안됨
- DEFAULT값을 NULL로 선언하면 DEFAULT 값 해제 가능

### 컬럼 이름 변경
```SQL
-- ORACLE
ALTER TABLE 테이블명
RENAME COLUMN 컬럼명 TO 새컬럼명;

-- SQL Server
EXEC sp_rename 'dbo.테이블명.컬럼명', '새컬럼명', 'COLUMN';

-- 예시
ALTER TABLE EMP
RENAME COLUMN ENAME TO FIRST_NAME;
```

- 컬럼의 이름 변경을 항상 가능 (데이터 존재 여부와 상관 X)
- **동시에 여러 컬럼 이름 변경 불가능**

### 테이블 이름 변경
```SQL
-- ORACLE
RENAME 테이블명 TO 새테이블명;
-- 예시
RENAME season1 TO season2;

-- SQL Server
sp_name 'dbo.테이블명', '새테이블명';
-- 예시
sp_name 'dbo.season1', 'season2';
```

### 컬럼 삭제
```SQL
ALTER TABLE 테이블명 DROP COLUMN 삭제할컬럼명;

-- 예시
ALTER TABLE PLAYER DROP COLUMN ADDRESS;
ALTER TABLE PLAYER DROP COLUMN ADDRESS, BIRTHDAY;   -- 오류
```

- 데이터 존재 여부와 상관없이 필요 없는 컬럼 삭제 가능
- **한 번에 하나의 컬럼만 삭제 가능**
- 컬럼 삭제 후 최소 하나 이상의 컬럼이 테이블에 존재해야 함
- 삭제된 컬럼은 복구가 불가능

### 객체(테이블, 인덱스 등) 삭제
```SQL
DROP TABLE 테이블명 [CASCADE CONSTRAINT];

-- 예시
DROP TABLE PLAYER;
```

- **테이블의 모든 데이터 및 구조를 삭제**
- CASCADE CONSTRAINT 옵션을 해당 테이블과 관계가 있었던 참조되는 데약조건에 대해서도 삭제한다는 것을 의미
- CASCADE CONSTRAINT 옵션을 지정하지 않으면 참조 중인 제약 조건이 있을 때 삭제가 불가능할 수 있음
- **SQL Server에서는 CASCADE 옵션이 X, 따라서 테이블을 삭제하기 전에 참조하는 FOREIGN KEY 제약조건 또는 참조하는 테이블을 먼저 삭제해야 함.**
- 삭제 후 복구 ROLLBACK 불가, 삭제 후 DESC로 확인불가

### TRUNCATE
```SQL
TRUNCATE TABLE 테이블명;
-- 예시
TRUNCATE TABLE PLAYER;
```

- 테이블 자체 삭제X, 테이블의 구조만 남기고 전체 데이터 삭제
- ROLLBACK 불가
- 삭제 후 DESC로 확인가능

### ⭐ DELETE / DROP / TRUNCATE TABLE 차이
<table>
    <thead style="text-align:center;">
        <tr>
            <td>DELETE</td>
            <td>DROP</td>
            <td>TRUNCATE</td>
        </tr>
    </thead>
    <tbody style="text-align:center;">
        <tr>
            <td>DML</td>
            <td colspan="2">DDL</td>
        </tr>
        <tr>
            <td>COMMIT이전이라면</br>ROLLBACK 가능</td>
            <td colspan="2">ROLLBACK 불가능 (AUTO COMMIT)</td>
        </tr>
        <tr>
            <td>데이 일부 또는 전체 삭제</td>
            <td>데이터와 테이블 구조 모두 삭제</td>
            <td>데이터 전체 삭제 / 테이블 구조는 남김</td>
        </tr>
        <tr>
            <td>데이터 하나씩 삭제</td>
            <td colspan="2">전체 데이터 한 번에 삭제</td>
        </tr>
    </tbody>
</table>

## 제약조건 (CONSTRAINT)
- 데이터의 무결성을 유지하기 위해 특정 컬럼에 설정하는 제약
- 테이블에 데이터가 올바르게 들어올 수 있도록 거는 제약 장치
    - EX) 학번은 NULL이면 안되고, 중복되어도 안됨 등
- 테이블 생성 시 정의 가능, 컬럼 추가 시 정의 가능
- 이미 생성된 컬럼에 제약조건만 추가 가능

### ⭐ PRIMARY KEY (기본키)
- 행 데이터를 고유하게 구별하는 식별자
- 중복 허용 X, NULL 허용 X => UNIQUE + NOT NULL
- 기본키 제약 정의하면 DBMS는 자동으로 UNIQUE 인덱스 생성함
- PK 생성하면 NOT NULL 특징 자동 부여
    - **그냥 NOT NULL이면 CTAS시 복사되나 PK로 인한 건 복사되지 X**
- 하나의 테이블에 하나의 기본키만 생성 가능
- 하나의 기본키를 여러 컬럼을 결합하여 생성할 수 있음
- 제약조건에 이름을 명시하고 싶으면 CONSTRANINT과 함께 이름을 전달해주면 된다.
    - 제약조건명 생략 시 DBMS에서 자동으로 이름을 부여함

#### 테이블 생성 시 제약조건 생성
```SQL
CREATE TABLE 테이블명 (
    컬럼1 데이터 타입 [DEFAULT 기본값] [CONSTRAINT 제약조건명] 제약조건종류,
    컬럼2 데이터 타입 [DEFAULT 기본값] [CONSTRAINT 제약조건명] 제약조건종류,
  ...
);

-- 복합키
CREATE TABLE 테이블명 (
    컬럼1 데이터타입,
    컬럼2 데이터타입,
    컬럼3 데이터타입,
    CONSTRAINT pk_제약조건명 PRIMARY KEY (컬럼1, 컬럼2)
);

-- 기본키, 외래키
CREATE TABLE 테이블명 (
    컬럼1 데이터타입,
    컬럼2 데이터타입,
    컬럼3 데이터타입,
    CONSTRAINT pk_제약조건명 PRIMARY KEY (컬럼1),
    CONSTRAINT fk_제약조건명 FOREIGN KEY (컬럼3) 
)
```

- 이렇게 밑에서 제약조건을 지정해 줄 수 있다.
- 이 방식은 복합키나 외래키 설정할 때 사용
- PK나 FK는 DEFAULT값 가지지 않음
    - PK는 고유성에 위배되며, FK의 경우 기본값이 참조 테이블에 존재하지 않는 경우 무결성 제약 조건을 위반할 위험이 있음

#### 컬럼 추가 시 제약조건 생성
```SQL
ALTER TABLE 테이블명
ADD 컬럼명 데이터타입 [DEFAULT 기본값] CONSTRAINT 제약조건명 제약조건종류;
```

#### 이미 생성된 컬럼에 제약조건 추가
```SQL
ALTER TABLE 테이블명
ADD CONSTRAINT 제약조건명 제약조건종류 (컬럼명);
```

#### 제약조건 삭제
```SQL
ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;
```

### UNIQUE (고유)
- 중복 허용X, **NULL 허용**, UNIQUE INDEX 자동 생성

```SQL
CREATE TABLE TEST (
    ID NUMBER,
    NAME VARCHAR2(10) UNIQUE
);

-- 예시
INSERT INTO TEST VALUES(1, 'a');
INSERT INTO TEST VALUES(2, 'a');    -- 중복값을 넣었으니 오류
INSERT INTO TEST VALUES(2, NULL);
INSERT INTO TEST VALUES(3, NULL);   -- NULL값은 상관없음
```

### NOT NULL
- 다른 제약조건과 달리 컬럼의 특징을 나타냄 => CTAS로 복제 시 따라감
- 컬럼 생성 시 NOT NULL을 선언하지 않으면 NULLABLE 컬럼으로 생성됨

```SQL
-- 예시
ALTER TABLE TEST ADD NOT NULL(COL1);    -- 불가능
ALTER TABLE TEST MODIFY COL1 NOT NULL;  -- 이렇게 써야함
ALTER TABLE TEST MODIFY COL1 
                CONSTRAINT test_c1_nn NOT NULL;    -- 제약조건에 이름 넣기
```

### FOREIGN KEY (외래키)
- **자식 테이블에 FK를 검**
- 참조테이블의 참조 컬럼에 있는 데이터를 확인하면서 본 테이블 데이터를 관리할 목적으로 생성
    - 부모 테이블의 특정 키의 있는 정보만을 가지고 자식 테이블의 데이터를 관리하겠하는 것
- **반드시 참조(부모)테이블의 참조 컬럼(REFERENCE KEY)이 사전에 PK 혹은 UNIQUE KEY를 가져야 함**

```SQL
CREATE TABLE 테이블명 (
    컬럼1 데이터타입 PRIMARY KEY,
    컬럼2 데이터타입,
    컬럼3 데이터타입 REFERENCES 참조테이블(참조컬럼)
);

CREATE TABLE 테이블명 (
    컬럼1 데이터타입,
    컬럼2 데이터타입,
    컬럼3 데이터타입,
    CONSTRAINT pk_제약조건명 PRIMARY KEY (컬럼1),
    CONSTRAINT fk_제약조건명 FOREIGN KEY (컬럼3) REFERENCE 참조테이블(참조컬럼)
);

-- 예시
CREATE TABLE EMP1 AS SELECT * FROM EMP;     -- 자식
CREATE TABLE DEPT1 AS SELECT * FROM DEPT;   -- 부모

-- 부모 테이블의 REFERENCE KEY(참조대상)에 PK설정
ALTER TABLE DEPT1
ADD CONSTRAINT DEPT_PK PRIMARY KEY(DEPTNO);

-- 자식 테이블에 FK 생성
ALTER TABLE EMP1 
ADD CONSTRAINT EMP_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT1(DEPTNO);
```

- 사원정보 보다는 부서정보가 먼저 만들어져야 함 -> 부서테이블이 부모

#### 💡 FK가 생성된 이후 부모와 자식 테이블에 걸리는 제약
- FK에 부모가 가지고 있는 정보값만 INSERT 가능
- UPDATE도 마찬가지로 부모가 가지고 있는 값으로만 가능
- DELETE는 상관 X
- 자식과 다르게 부모는 삭제 불가 (자식이 있는 상태에서 삭제 불가)
- 자식이 이미 있는 상태에서 값수정도 불가능

```SQL
-- 자식 테이블에서 3번 부서원 삭제 시도
DELETE EMP1 WHERE DEPTNO = 3;   -- 가능

-- 자식 테이블에서 5번 부서원을 50번으로 변경 시도
UPDATE EMP1 SET DEPTNO = 50 WHERE DEPTNO = 20;  -- 불가능

-- 자식 테이블에서 50번 부서원 입력 시도
INSERT INTO EMP1(EMPNO, ENAME, DEPTNO)
VALUES('101', 'RICK', 50);  -- 불가능
```

- 부모 테이블에서 50번 부서번호가 정의되어 있지 않아 자식 테이블에서 해당 값으로 수정이 불가능하고, 해당 값으로의 입력도 불가능한 것이다.

```SQL
-- 부모 테이블에서 3번 부서 삭제 시도
DELETE DEPT1 WHERE DEPTNO = 3;  -- 불가능

-- 부모 테이블에서 3번 부서를 70번 부서로 변경 시도
UPDATE DEPT1 SET DEPTNO = 70 WHERE DRPTNO = 3;  -- 불가능
```

- 3번 부서 정보가 자식 테이블에 이미 존재하니 삭제 및 변경 불가

#### 💡 FOREIGN KEY 옵션 (생성 시 정의, 변경 불가 -> 재생성해야)
① **ON DELETE CASCADE**
- 부모 데이터 삭제 시 자식 데이터도 함께 삭제

② ON DELETE SET NULL
- 부모 데이터 삭제 시 자식 테이터의 참조값은 NULL로 수정

```SQL
ALTER TABLE EMP1 DROP CONSTRAINT EMP_FK;

ALTER TABLE EMP1 ADD CONSTRAINT EMP_FK
    FOREIGN KEY(DEPTNO) REFERENCES DEPT1(DEPTNO) FK옵션;

-- 부모 테이블에서 3번 부서 삭제 시도
-- 1) ON DELETE CASCADE
DELETE DEPT1 WHERE DEPTNO = 3;
SELECT * FROM EMP1 WHERE DEPTNO = 3;    -- 자식 데이터 삭제됨

-- 2) ON DELETE SET NULL
DELETE DEPT1 WHERE DEPTNO = 3;
SELECT * FROM EMP1 WHERE ENAME = 'RICK';    -- DEPTNO 컬럼만 NULL 값, 나머지 데이터는 그대로 존재
```

### CHECK
- 직접적으로 데이터의 값 제한 (도메인 범위를 정해주는 느낌)

```SQL
ALTER TABLE EMP1 ADD CONSTRAINT EMP_SAL_CK CHECK (SAL > 0);
```

#### ⭐⭐
- 제약조건: 데이터 무결성 유지
- PRIMARY KET(기본키): UNIQUE & NOT NULL
- UNIQUE KEY(고유키): 고유(중복X), NULL 허용
- NOT NULL: NULL값 불가
- CHECK: 입력 값 범위 제한
- FOREIGN KEY(외래키): NULL 가능, 여러개 가능
- 자식 테이블: 참조 컬럼의 값 수정과 입력에 제약
- 부모 테이블: 수정과 삭제에 제약

### ⭐ 참조 동작(Referential Action)
#### DELTE / MODIFY Action (부서[부모] - 사원[자식])
- CASCADE: 부모 삭제 시 자식도 같이 삭제
- SET NULL: 부모 삭제 시 자식의 해당 필드는 NULL로 설정
- SET DEFAULT: 부모 삭제 시 자식의 해당 필드를 DEFAULT 값으로 설정
- **RESTRICT**: 부모 삭제 시 자식 테이블에 PK가 없응 경우에만 부모 삭제 허용
- NO ACTION: 참조 무결성을 위반하는 삭제/수정 액션은 취하지 않는다.

#### INSERT Action (부서[부모] - 사원[자식]) '자식테이블의 FK 데이터 생성 시'
- AUTOMATIC: 자식 삽입 시 부모 테이블에 PK가 없으면, 부모 PK 생성 후 자식에 삽입
- SET NULL: 자식 삽입 시 부모 테이블에 PK가 없으면, 자식 외부키를 NULL값으로 설정
- SET DEFAULT: 자식 삽입 시 부모 테이블에 PK가 없으면, 자식 외부키를 지정된 DEFAULT 값으로 설정
- DEPENDENT: 자식 삽입시 부모 테이블에 PK가 존재할 때만, 자식 삽입 허용
- NO ACTION: 참조 무결성을 위반하는 삽입 액션을 취하지 않는다.

### 기타
### 뷰(VIEW)
- 저장공간을 가지지는 않으나 테이블처럼 조회 및 수정 가능한 객체
- 가상 테이블이라고도 함

### 뷰의 종류
- 단순뷰: 하나의 테이블로 조회 결과를 만든 뷰
- 복합뷰: 둘 이상의 테이블 조인해서 만든 뷰

### 뷰의 특징
- 기본 테이블과 같은 형태의 구조를 가진다.
- 뷰는 가상 테이블이라 물리적으로 구현되어 있지 않으니 저장공간을 차지하지 않는다.
- **데이터를 안전하게 보호 가능하다.**
- **이미 정의되어 있는 뷰는 다른 뷰의 정의에 기초가 될 수 있다.**
- **기본 테이블이 삭제되면 그 테이블을 참조하여 만든 뷰 역시 삭제된다.**
- **단지 정의만을 가지며, 실행 시점에 질의를 재작성하여 수행한다.**
- 실제 데이터를 저장하고 있는 뷰를 생성하는 기능을 지원하는 DBMS도 있다.

### 뷰의 장점
① 독립성
- 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변하지 않아도 됨

② 편리성
- 복잡한 쿼리(질의)를 뷰로 생성함으로써 관련 질의를 단순하게 작성 가능
- 해당 형태의 SQL 문을 자주 사용할 때 뷰를 이용하면 평리하게 사용 가능

③ 보안성
- 직원의 급여정보와 같이 숨기고 싶은 정보가 존재한다면, 뷰를 생성할 때 해당 컬럼을 빼고 생성함으로써 사용자에게 정보를 감출 수 있음

④ 그 외
- 사용자의 데이터 권리 단순화
- 데이터의 다양한 지원가능

### 뷰의 단점
- 뷰의 정의 변경 불가
- 삽입, 삭제, 갱신 연산에 제한
- 인덱스 구성 불가

```SQL
-- 뷰 생성
CREATE [OR REPLACE] VIEW 뷰이름
AS
조회쿼리;

-- 뷰 삭제
DROP VIEW 뷰이름;

-- 뷰 생성 예시
CREATE VIEW V_EMP_DEPT
AS
SELECT E.EMPNO, E.NAME, E.DEPTNO, D.NAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

-- 뷰를 통한 조회
SELECT * FROM V_EMP_DEPT;
```

- 특정 쿼리를 업무에서 자주 사용해야 할 경우, 매번 동일한 쿼리를 입력하는 것은 번거롭고 비효율적이다.
- 이럴 때 뷰(VIEW)를 사용하면, 복잡한 쿼리를 미리 정의해두고 이를 참조하여 쉽게 조회할 수 있다.
- 복잡한 쿼리 결과를 기반으로 뷰를 생성하면, 사용자는 뷰의 이름만으로 해당 쿼리의 결과를 쉽게 조회할 수 있다.
- 뷰에 데이터가 저장되는 개념이 아니라 원본 테이블의 데이터가 변경되면, 변경되는 대로 조회가 된다.
    - 뷰 조회할때마다 쿼리가 실행되는 개념

### 기타2
### 시퀀스 (SEQUENCE)
- 자동으로 연속적인 숫자 부여해주는 객체

```SQL
CREATE SEQUENCE 시퀀스명
INCREMENT BY        -- 증가값 (DEFAULT: 1)
START WITH          -- 시작값 (DEFAULT: 1)
MAXVALUE            -- 마지막값(증가시퀀스), 재사용시 시작값(감소시퀀스)
MINVALUE            -- 재사용시 시작값(증가시퀀스), 마지막값(감소시퀀스)
CYCLE | NOCYCLE     -- 시퀀스 번호 재사용 (DEFAULT: NOCYCLE)
CACHE N             -- 캐시값 (DEFAULT: 20)
;
```

- 캐시값 : 메모리에 미리 올려넣는 값

### 기타3
### 시노님 (SYNONYM)
- 테이블 별칭 생성
    - EX) JOHN 계정에서 SCOTT.EMP를 EMP로 조회하는 방법
    - 본인 소유의 테이블이 아니라면 테이블 앞에 소류자명을 붙여야 함(권한이 있다는 가정하에)
    - 매번 소유자명을 붙이기 번거로우리 EMP라는 별칭을 준 것

```SQL
CREATE [OR REPLACE] [PUBLIC] SYNONYM 별칭 FOR 테이블명;

-- 시노님 생성
CREATE PUBLIC SYNONYM EMP FOR SCOTT.EMP;
-- 시노님 생성 후 테이블 조회
SELECT * FROM EMP;
```

- OR REPLACE: 기존에 같은 이름의 시노님이 있는 경우 대체
- PUBLIC: 누구나 사용 가능
    - PRIVATE로 할 경우, 시노님을 생성한 유저만 사용 가능
    - PUBILC으로 생성한 시노님은 반드시 PUBLIC으로 삭제

## DCL (Data Control Language)
### DCL
- 데이터 제어어로 객체에 대한 권한 부여(GRANT)하거나 권한 회수(REVOKE)
- 테이블 소유자는 타계정에 테이블 조회 및 수정 권한 부여와 회수 가능

### 권한
- 일반적으로 본인(접속한 계정) 소유가 아닌 테이블은 원칙적으로 조회 불가
- 업무적으로 필요시 테이블 소유가자 아닌 계정에 테이블 조회, 수정 권한 부여 가능

### ORACLE 기본 유저 종류
- SCOTT: 테이스용 샘플 유저 (DEFAULT 패스워드: TIGER)
- SYS: DBA ROLE을 부여받은 유저
- SYSTEM: DB의 모든 권한을 부여받은 DBA 유저 (ORACLE 설치 완료 시 패스워드 설정)

### 권한 종류
① 오브젝트 권한
- 테이블에 대한 권한 제어
- EX) 특정 테이블에 대한 DML(SELECT, INSERT, UPDATE, DELETE, MERGE) 권한
- **테이블 소유자는 타계정에 소유 테이블에 대한 조회 및 수정 권한 부여 및 회수 가능**

② 시스템 권한
- 시스템 작업을 제어
- EX) 테이블 생성 권한, 인덱스 삭제 권한 (DDL 권한)
- **관리자 권한만 권한 부여 및 회수가 가능**

### GRANT
- 권한 부여시 반드시 테이블 소유자나 관리자계정(SYS, SYSTEM)으로 접속하여 권한을 부여해야 함
- 동시에 여러 유저에 대한 권한 부여 가능
- 동시에 여러 권한 부여 가능
- 동시에 여러 객체 권한 부여 불가

```SQL
-- 오브젝트 권한 부여
GRANT 권한 ON 테이블명 TO 유저;

-- 예시
GRANT SELECT ON EMP TO A;
GRANT SELECT ON EMP TO A, B;
GRANT SELECT, UPDATE, INSERT ON EMP TO B;
GRANT SELECT ON EMP, DEPT ON A; -- 불가능
```

### REVOKE
- 동시에 여러 권한 회수 가능
- 이미 회수된 권한을 재회수 불가
- 동시 여러 유저로부터의 권한 회수 가능

```SQL
-- 오브젝트 권한 회수
REVOKE 권한 ON 테이블명 FROM 유저;

-- 예시
REVOKE SELECT, UPDATE, INSERT ON EMP FROM A;
REVOKE SELECT ON EMP FROM A, B;
REVOKE SELECT ON EMP FROM A, B;     -- 오류(이미 회수된 권한임)
```

#### ORACLE
- 테이블 소유권: ORACLE에서는 테이블이나 다른 오브젝트의 소유자는 해당 오프젝트를 생성한 유저(User)
- 권한 부여: 다른 사용자가 특정 테이블에 접근하여면, 해당 테이블을 소유한 유저가 개별적으로 권한을 부여해야 함

#### SQL Server
- 스키마와 소유권: SQL Server에서는 오브젝트가 유저가 아닌 스키마에 의해 소유된다.
- 유저는 오브젝트를 직접 소유하지 않고, 특정 스키마에 대한 권한을 부여받아야 그 스키마의 오브젝트에 접근할 수 있다.
    - EX) dbo.테이블명에서 dbo는 스키마를 나타낸다.
    - 유저는 dbo 스키마에 대한 권한을 받아야만 해당 스키마 내의 오브젝트를 사용할 수 있게 된다.
- 권한 부여 방식: GRANT SELECT ON 스키마명.테이블명 TO 유저;

### 롤 (ROLE)
- 유저를 생성하면 기본적으로 CREATE SESSION, CREATE TABLE 등 많은 권한을 부여해야 한다.
- DB관리자는 유저가 생성될 때마다 각각의 권한들을 유저에게 부여하는 작업을 수행해야 하며, 유저가 점점 늘어나고 자주 변경되는 상황에서 이는 매우 번거로운 작업이 된다.
- 이런 문제를 해결하기 위해 DB관리자는 ROLE을 생성하고, ROLE에 각종 권한들을 부여한 후 ROLE을 다른 ROLE이나 유저에게 부여한다.
- ROLE은 DB에서 유저들과 권한들 사이에서 중개역할을 함
- ROLE은 유저에게 직접 부여될 수도 있고, 다른 ROLE에 포함하여 유저에게 부여될 수 있다.
- 다양한 권한의 묶음으로 SYSTEM 계정에서 생성 가능

```SQL
-- 롤 생성을 위해 시스템계정으로 로그인
CONN SYSTEM/MANAGER

CREATE ROLE 롤이름;                 -- 롤 생성
GRANT 권한1, 권한2, .. TO 롤이름;     -- 롤에 권한 부여
GRANT 롤이름 TO 유저;               -- 권한 집합인 롤을 유저에게 부여

-- 롤 생성
CREATE ROLE ROLE1;
-- 롤에 권한 담기
GRANT SELECT ON EMP TO ROLE1;
GRANT SELECT ON DEPT TO ROLE1;
-- 유저에게 롤 부여
GRANT ROLE1 TO A;
```

- [A 계정에서 수행] SELECT * FROM SCOTT.DEPT
- 유저A는 EMP와 DEPT 테이블 조회 가능
- 💡 주의
    - 원래 권한은 '즉시' 반영이 된다.
    - 접속해 있는 상태에서 권한을 받으면 재접속을 할 필요가 없다.
    - 하지만, 롤은 반드시 재접속을 해야만 권한이 부여된다.

```SQL
-- 롤에서 특정 권한 빼기
REVOKE SELECT ON DEPT FROM ROLE1

-- [권한 회수 후 A 계정에서 조회]
SELECT * FROM SCOTT.DEPT;   -- 오류: 권한 불충분

-- [SCOTT에서 실행] 롤을 통해 부여한 권한 직접 회수하기
REVOKE SELECT ONEMP FROM A; -- 오류
```

- 롤에서 회수된 권한은 즉시 반영되므로 다시 롤을 부여할 필요가 없음
- **롤을 통해 부여한 권한은 직접 회수가 불가능**
- **롤을 통해 부여한 권한은 롤을 통한 회수만 가능**

### 권한부여 옵션 (중간관리자의 권한)
- 권한은 보통 최상위 관리자들이 부여하는데, 그럴 경우 최상위 관리자들이 너무 많은 유저들에게 권한부여 및 회수를 하게 된다.
- 중간관리자를 두어 중간관리자에게 특정 권한을 일임하여 중간관리자가 자유롭게 제 3자에게 권한을 부여하거나 회수할 수 있게 한다.

#### WITH GRANT OPTION
- 오브젝트 권한에 대해 다른 사용자에게 해당 권한 부여 가능
- **중간관리자 부여한 권한은 중간관리자만 회수 가능**
    - 시스템 관리자, 최상위 관리자에서 직접 회수 불가능
- **중간관리자에게 부여된 권한 회수 시 제 3자에게 부여된 권한도 함께 회수됨**

#### WITH ADMIN OPTION
- 시스템 권한 / 롤 권한을 다른 사용자에게 부여 가능
- **중간관리자를 거치지 않고 직접 회수 가능**
- **중간관리자의 권한 회수 시 제 3자에게 부여된 권한은 남아있음**

#### EX) 최고 관리자 lee / 중간관리자 kim / 제 3자 park
- lee가 kim에게 WITH GRANT OPTION으로 오브젝트 권한 부여
- 중간관리자가 된 kim이 park에서 DML 권한 부여
    - lee가 park의 권한 직접 회수 불가능
    - lee가 kim의 권한을 회수 시, park의 권한까지 모두 회수됨
- lee가 kim에게 WITH ADMIN OPTION으로 시스템 권한 부여
- 중간관리자, kim이 park에게 DDL 권한 부여
    - lee가 park의 권한 직접 회수 가능
    - lee가 kim의 권한을 회수 시, park의 권한은 남아있음.
